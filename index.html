<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/techSnapshot.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/techSnapshot.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/techSnapshot.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/techSnapshot.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/techSnapshot.github.io/css/main.css">


<link rel="stylesheet" href="/techSnapshot.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"programmerlz.github.io","root":"/techSnapshot.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="小楼昨夜又东风">
<meta property="og:url" content="https://programmerlz.github.io/index.html">
<meta property="og:site_name" content="小楼昨夜又东风">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liu">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://programmerlz.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>小楼昨夜又东风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/techSnapshot.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小楼昨夜又东风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/techSnapshot.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/techSnapshot.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/07/25/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/07/25/Java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 20:29:29 / 修改时间：20:31:35" itemprop="dateCreated datePublished" datetime="2021-07-25T20:29:29+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">程序语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>前两天参与了一次面试，感觉自己写业务代码写的脑子都生锈了，很多Java基础上的东西，虽然之前学过，脑子有一个大致的印象但是几乎忘得都差不多了，面试前准备的也不够充分，回答的也只是蜻蜓点水一样，感觉可能要凉凉了。过阵子可能还要面试，趁周末，重温一下这些较为基础的东西吧。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="最简单的考虑"><a href="#最简单的考虑" class="headerlink" title="最简单的考虑"></a>最简单的考虑</h4><p>最简单的考虑，可以认为是一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(key,value)</span><br></pre></td></tr></table></figure>

<p>对key做一个hash运算，然后跟底层的数组的长度进行取模就能够得到元素在数组中的索引，然后把value放进数组中的索引指向处即可。</p>
<h3 id="JDK的优化"><a href="#JDK的优化" class="headerlink" title="JDK的优化"></a>JDK的优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;测试数据&quot;</span>)；</span><br></pre></td></tr></table></figure>

<p>针对上边代码，JDK中对key的hash值的计算有优化，下边是一段hash计算的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (he = key.hashCode() ^ (h&gt;&gt;&gt;<span class="number">16</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>^ : 异或</p>
<p>h&gt;&gt;&gt;16：将h右移16位</p>
<p>假设h的hashcode为：1111 1111 1111 1111 1111 1010 0111 1100</p>
<p>那么h&gt;&gt;&gt;16则为：      0000 0000 0000 0000 1111 1111 1111 1111</p>
<p>二者异或操作后为：    1111 1111 1111 1111 0000 0101 1000 0011</p>
<p>转换为int值，</p>
</blockquote>
<p>为什么要这么优化呢？优化的是什么呢？后续会说，稍安勿躁。</p>
<p>下边是在数组中进行寻址的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n-<span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n为数组的长度：假设为16</p>
<p>二进制的n-1：0000 0000 0000 0000 0000 0000 0000 1111</p>
</blockquote>
<p>这段寻址的代码，等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash % n</span><br></pre></td></tr></table></figure>

<p>但是，要比 hash % n要高效得多。前提是 n = 2的整数倍次方。</p>
<p>进行&amp;运算的时候，由于一般情况下，底层数组的长度n都是不会超过32位的，因此，<strong>与hashcode的高16位的运算没什么意义，最终都是0，核心在于低16位的运算</strong>。</p>
<p>现在，就能够知道为什么hash方法到底是做了什么优化了。</p>
<p>hash方法的逻辑是，<strong>将key的hashcode右移16位后与原hashcode进行异或操作</strong>，这就能够让<strong>最终得到的hashcode的低16位同时拥有原hashcode的高16位和低16位的特征，从而降低了hashcode的低16位相同的概率，进而降低了寻址操作得到相同地址的概率。</strong></p>
<p>其实，最终就是为了避免过多的哈希冲突，这个在下一小节去说。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(A,<span class="string">&quot;测试数据&quot;</span>)；</span><br><span class="line">map.put(B,<span class="string">&quot;测试数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上边的代码，当A和B在寻址计算完毕之后，假设得到的在数组中的位置都是index0，那么他么就对应了数组中的同一个位置，这种情况被称为哈希冲突。</p>
<p>产生哈希冲突的时候，则会在这个位置挂一个链表，在链表中放入多个元素，让多个键值对，同时放在数组的一个位置离。当做get操作的时候，只需要遍历这个链表从中找到要找的那个值即可。</p>
<p>如果某个位置的链表变得很长，会导致遍历的效率变低，时间复杂度为O(n)，此时就会将这个链表转换为红黑树，遍历红黑树的时间复杂度为O(n)。</p>
<h3 id="Hashmap扩容"><a href="#Hashmap扩容" class="headerlink" title="Hashmap扩容"></a>Hashmap扩容</h3><p>当底层的数组满了之后，会进行扩容，会将原来的容量乘以2。同时，会进行Rehash。这个Rehash的操作指的就是将原来map中的元素重新进行对数组的新长度进行寻址操作。因为数组的长度改变，因此Rehash操作之后，得到的在数组中的新地址可能会与之前的地址不一样。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/07/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/07/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/" class="post-title-link" itemprop="url">微服务架构的演进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-24 20:58:35" itemprop="dateCreated datePublished" datetime="2021-07-24T20:58:35+08:00">2021-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/07/23/Java-NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/07/23/Java-NIO/" class="post-title-link" itemprop="url">Java NIO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-23 17:31:34" itemprop="dateCreated datePublished" datetime="2021-07-23T17:31:34+08:00">2021-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 20:33:03" itemprop="dateModified" datetime="2021-07-25T20:33:03+08:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">程序语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-NIO：Buffer、Channel-和-Selector"><a href="#Java-NIO：Buffer、Channel-和-Selector" class="headerlink" title="Java NIO：Buffer、Channel 和 Selector"></a>Java NIO：Buffer、Channel 和 Selector</h1><p>本文将介绍 Java NIO 中三大组件 <strong>Buffer、Channel、Selector</strong> 的使用。    </p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是<strong>内存中的一块</strong>，我们可以将数据写入这块内存，之后从这块内存获取数据。</p>
<p>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/6.png"></p>
<p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p>
<p><strong>我们应该将 Buffer 理解为一个数组</strong>，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p>
<p><strong>MappedByteBuffer</strong> 用于实现内存映射文件，也不是本文关注的重点。</p>
<p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。</p>
<h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/5.png" alt="5"></p>
<p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p>
<p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p>
<p><strong>position</strong> 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p>
<p>从写操作模式到读操作模式切换的时候（<strong>flip</strong>），position 都会归零，这样就可以从头开始读写了。</p>
<p><strong>Limit</strong>：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/7.png" alt="7"></p>
<h3 id="初始化-Buffer"><a href="#初始化-Buffer" class="headerlink" title="初始化 Buffer"></a>初始化 Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">IntBuffer intBuf = IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">LongBuffer longBuf = LongBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h3><h4 id="第一种方式：直接填充"><a href="#第一种方式：直接填充" class="headerlink" title="第一种方式：直接填充"></a>第一种方式：直接填充</h4><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充一个 byte 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 在指定位置填充一个 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 将一个数组中的值填充进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 <strong>java.nio.BufferOverflowException</strong> 异常。</p>
<h4 id="第二种方式：通道填充-就是从通道中读数据填充"><a href="#第二种方式：通道填充-就是从通道中读数据填充" class="headerlink" title="第二种方式：通道填充(就是从通道中读数据填充)"></a>第二种方式：通道填充(就是从通道中读数据填充)</h4><p>对于 Buffer 来说，另一个常见的操作中就是，我们要<strong>将来自 Channel 的数据填充到 Buffer 中</strong>，在系统层面上，这个操作我们称为<strong>读操作</strong>，因为数据是从外部（文件或网络等）读到内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.read(buf);</span><br></pre></td></tr></table></figure>

<p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p>
<h3 id="提取-Buffer-中的值"><a href="#提取-Buffer-中的值" class="headerlink" title="提取 Buffer 中的值"></a>提取 Buffer 中的值</h3><h4 id="填充-gt-提取的模式切换"><a href="#填充-gt-提取的模式切换" class="headerlink" title="填充-&gt;提取的模式切换"></a>填充-&gt;提取的模式切换</h4><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向<strong>最后一次写入的位置的后面一个</strong>，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p>
<p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p>
<p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position; <span class="comment">// 将 limit 设置为实际写入的数据数量</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 重置 position 为 0</span></span><br><span class="line">    mark = -<span class="number">1</span>; <span class="comment">// mark 之后再说</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接读"><a href="#直接读" class="headerlink" title="直接读"></a>直接读</h4><p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 将 Buffer 中的数据写入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span></span><br></pre></td></tr></table></figure>

<p>附一个经常使用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(buffer.array()).trim();</span><br></pre></td></tr></table></figure>

<h4 id="通道读"><a href="#通道读" class="headerlink" title="通道读"></a>通道读</h4><p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是<strong>将我们写入的数据传输到 Channel 中</strong>，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为<strong>写操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.write(buf);</span><br></pre></td></tr></table></figure>

<h3 id="mark-amp-reset-基本上是成对使用"><a href="#mark-amp-reset-基本上是成对使用" class="headerlink" title="mark() &amp; reset()(基本上是成对使用)"></a>mark() &amp; reset()(基本上是成对使用)</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 <strong>mark</strong>。</p>
<p><strong>mark 用于临时保存 position 的值</strong>，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rewind-amp-clear-amp-compact"><a href="#rewind-amp-clear-amp-compact" class="headerlink" title="rewind() &amp; clear() &amp; compact()"></a>rewind() &amp; clear() &amp; compact()</h3><p>**rewind()**：会重置 position 为 0，通常用于重新从头读写 Buffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**clear()**：有点重置 Buffer 的意思，相当于重新实例化了一样。</p>
<p>**通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**compact()**：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p>
<p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只<strong>不过后续的写入会覆盖掉原来的数据</strong>，也就相当于清空了数据了。</p>
<p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/8.png" alt="8"></p>
<ul>
<li><strong>FileChannel</strong>：文件通道，用于文件的读和写</li>
<li><strong>DatagramChannel</strong>：用于 UDP 连接的接收和发送</li>
<li><strong>SocketChannel</strong>：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li>
<li><strong>ServerSocketChannel</strong>：TCP 对应的服务端，用于监听某个端口进来的请求</li>
</ul>
<p><strong>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code>。</strong></p>
<p>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/9-20190522151756191.png" alt="9"></p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/10.png" alt="10"></p>
<p>至少读者应该记住一点，这两个方法都是 channel 实例的方法。</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，<strong>FileChannel 是不支持非阻塞的</strong>。</p>
<p><strong>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</strong></p>
<p><strong>初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;/data.txt&quot;</span>));</span><br><span class="line">FileChannel fileChannel = inputStream.getChannel();</span><br></pre></td></tr></table></figure>

<p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p>
<p><strong>读取文件内容：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>

<p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。</p>
<p><strong>写入文件内容：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">buffer.put(<span class="string">&quot;随机写入一些内容到 Buffer 中&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// Buffer 切换为读模式</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    <span class="comment">// 将 Buffer 中的内容写入文件</span></span><br><span class="line">    fileChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解<strong>有点狭隘</strong>(确实有点狭隘)，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p>
<p>打开一个 TCP 连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;https://www.javadoop.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<p>当然了，上面的这行代码等价于下面的两行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个通道</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;https://www.javadoop.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">socketChannel.read(buffer);<span class="comment">//Read data from net.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据到网络连接中</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(buffer);<span class="comment">//Write data to net.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要在这里停留太久，先继续往下走。</p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p>
<p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 监听 8080 端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以看到 SocketChannel 的第二个实例化方式</p>
</blockquote>
<p>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，<strong>它代表的是一个网络通道，可读可写</strong>。</p>
<p><strong>ServerSocketChannel 不和 Buffer 打交道</strong>，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为<strong>它需要继续监听端口，等待下一个连接</strong>。</p>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p>
<blockquote>
<p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</p>
</blockquote>
<p><strong>监听端口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure>

<p><strong>发送数据：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">&quot;New String to write to file...&quot;</span></span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();<span class="comment">//变为读数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;jenkov.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在<strong>非阻塞</strong>的基础之上，大家经常听到的 <strong>多路复用</strong> 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p>
<p>多路复用这个概念，可以再开启一篇文章。</p>
<p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p>
<ol>
<li><p>首先，我们开启一个 Selector。你们爱翻译成<strong>选择器</strong>也好，<strong>多路复用器</strong>也好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li>
<li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel 不支持非阻塞</strong>，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>register 方法的第二个 int 型参数（使用二进制的标记位）<strong>用于表明需要监听哪些感兴趣的事件</strong>，共以下四种事件：</p>
<ul>
<li><p>SelectionKey.OP_READ</p>
<blockquote>
<p>对应 00000001，通道中有数据可以进行读取</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_WRITE</p>
<blockquote>
<p>对应 00000100，可以往通道中写入数据</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_CONNECT</p>
<blockquote>
<p>对应 00001000，成功建立 TCP 连接</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_ACCEPT</p>
<blockquote>
<p>对应 00010000，接受 TCP 连接</p>
</blockquote>
</li>
</ul>
<p>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000<strong>1</strong>000<strong>1</strong> 即十进制数值 17 即可。</p>
<p>注册方法返回值是 <strong>SelectionKey</strong> 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p>
</li>
<li><p>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</p>
</li>
</ol>
<p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();<span class="comment">//获取多路复用器</span></span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置通道非阻塞</span></span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);<span class="comment">//把通道感兴趣的事件向多路复用器注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否有事件准备好</span></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Selector，我们还需要非常熟悉以下几个方法：</p>
<ol>
<li><p><strong>select()</strong></p>
<p>调用此方法，会将<strong>上次 select 之后的</strong>准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p>
</li>
<li><p><strong>selectNow()</strong></p>
<p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会<strong>立即返回</strong> 0。</p>
</li>
<li><p><strong>select(long timeout)</strong></p>
<p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会<strong>等待一会</strong>。</p>
</li>
<li><p><strong>wakeup()</strong></p>
<p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p>
</li>
</ol>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射文件和之前说的 标准IO操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一 部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p>
<p><strong>内存映射经过实际测量，发现在小文件读取的时候不如传统的方式读取文件性能好。因此比较适用于读取大文件。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p>
<p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p>
<p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p>
<p><strong>Selector 用于实现非阻塞 IO</strong>，这里仅仅介绍接口使用。</p>
<h1 id="Java-非阻塞-IO-和异步-IO"><a href="#Java-非阻塞-IO-和异步-IO" class="headerlink" title="Java 非阻塞 IO 和异步 IO"></a>Java 非阻塞 IO 和异步 IO</h1><p>以上介绍了 Java NIO 中 Buffer、Channel 和 Selector 的基本操作，主要是一些接口操作，比较简单。</p>
<p>在此将介绍<strong>非阻塞 IO</strong> 和<strong>异步 IO</strong>，也就是大家耳熟能详的 NIO 和 AIO。很多初学者可能分不清楚异步和非阻塞的区别，只是在各种场合能听到<strong>异步非阻塞</strong>这个词。</p>
<p>本文会先介绍并演示阻塞模式，然后引入非阻塞模式来对阻塞模式进行优化，最后再介绍 JDK7 引入的异步 IO，由于网上关于异步 IO 的介绍相对较少，所以这部分内容我会介绍得具体一些。</p>
<p>希望看完本文，读者可以对非阻塞 IO 和异步 IO 的迷雾看得更清晰些，或者为初学者解开一丝丝疑惑也是好的。</p>
<h2 id="阻塞模式-IO"><a href="#阻塞模式-IO" class="headerlink" title="阻塞模式 IO"></a>阻塞模式 IO</h2><p>我们已经介绍过使用 Java NIO 包组成一个简单的<strong>客户端-服务端</strong>网络通讯所需要的 ServerSocketChannel、SocketChannel 和 Buffer，我们这里整合一下它们，给出一个完整的可运行的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不显示设置，默认ServerSocketChannel是阻塞的</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听 8080 端口进来的 TCP 链接</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里会阻塞，直到有一个请求的连接进来</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启一个新的线程来处理这个请求，然后在 while 循环中继续监听 8080 端口</span></span><br><span class="line">            SocketHandler handler = <span class="keyword">new</span> SocketHandler(socketChannel);</span><br><span class="line">            <span class="keyword">new</span> Thread(handler).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下新的线程需要做什么，SocketHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketHandler</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求数据读入 Buffer 中</span></span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="keyword">while</span> ((num = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;<span class="comment">//这里也可能会发生阻塞</span></span><br><span class="line">                <span class="comment">// 读取 Buffer 内容之前先 flip 一下</span></span><br><span class="line">                buffer.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取 Buffer 中的数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[num];</span><br><span class="line">                buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                String re = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到请求：&quot;</span> + re);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回应客户端</span></span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.wrap((<span class="string">&quot;我已经收到你的请求，你的请求内容是：&quot;</span> + re).getBytes());</span><br><span class="line">                <span class="comment">//把Buffer当中的数据写入socket通道，也可能会发生阻塞，因为通道此时可能不可写入</span></span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            IOUtils.closeQuietly(socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，贴一下客户端 SocketChannel 的使用，客户端比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(<span class="string">&quot;1234567890&quot;</span>.getBytes());</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取响应</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">if</span> ((num = socketChannel.read(readBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            readBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] re = <span class="keyword">new</span> <span class="keyword">byte</span>[num];</span><br><span class="line">            readBuffer.get(re);</span><br><span class="line"></span><br><span class="line">            String result = <span class="keyword">new</span> String(re, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;返回值: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面介绍的阻塞模式的代码应该很好理解：来一个新的连接，我们就新开一个线程来处理这个连接，之后的操作全部由那个线程来完成。</p>
<p>那么，这个模式下的性能瓶颈在哪里呢？</p>
<ol>
<li><p>首先，<strong>每次来一个连接都开一个新的线程</strong>这肯定是不合适的。当活跃连接数在几十几百的时候当然是可以这样做的，但如果活跃连接数是几万几十万的时候，这么多线程明显就不行了。每个线程都需要一部分内存，内存会被迅速消耗，同时，线程切换的开销非常大。</p>
<blockquote>
<p>活跃连接数：服务端正在处理事情的（没有sleep的）线程数。</p>
<p>缺点：活跃连接数很多的时候：</p>
<ul>
<li>消耗内存</li>
<li>线程切换开销大</li>
</ul>
</blockquote>
</li>
<li><p>其次，阻塞操作在这里也是一个问题。首先，accept() 是一个阻塞操作，当 accept() 返回的时候，代表有一个连接可以使用了，我们这里是马上就新建线程来处理这个 SocketChannel 了，但是，但是这里不代表对方就将数据传输过来了。所以，SocketChannel#read 方法将阻塞，等待数据，明显这个等待是不值得的。同理，write 方法也需要等待通道可写才能执行写入操作，这边的阻塞等待也是不值得的。</p>
</li>
</ol>
<blockquote>
<p>缺点：read和write都会造成线程阻塞，低效</p>
</blockquote>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>说完了阻塞模式的使用及其缺点以后，我们这里就可以介绍非阻塞 IO 了。</p>
<p>非阻塞 IO 的核心在于<strong>使用一个 Selector 来管理多个通道</strong>，可以是 SocketChannel，也可以是 ServerSocketChannel，将各个通道注册到 Selector 上，指定监听的事件。</p>
<p>之后可以只用一个线程来轮询这个 Selector，看看上面是否有通道是准备好的，当通道准备好可读或可写，然后才去开始真正的读写，这样速度就很快了。我们就完全没有必要给每个通道都起一个线程。</p>
<p><strong>NIO 中 Selector 是对底层操作系统实现的一个抽象</strong>，管理通道状态其实都是底层系统实现的，这里简单介绍下在不同系统下的实现。</p>
<p><strong>select</strong>：上世纪 80 年代就实现了，它支持注册 FD_SETSIZE(1024) 个 socket，在那个年代肯定是够用的，不过现在嘛，肯定是不行了。</p>
<p><strong>poll</strong>：1997 年，出现了 poll 作为 select 的替代者，最大的区别就是，<strong>poll 不再限制 socket 数量</strong>。</p>
<p>select 和 poll 都有一个共同的问题，那就是<strong>它们都只会告诉你有几个通道准备好了，但是不会告诉你具体是哪几个通道</strong>。所以，一旦知道有通道准备好以后，自己还是需要进行一次扫描，显然这个不太好，通道少的时候还行，一旦通道的数量是几十万个以上的时候，扫描一次的时间都很可观了，时间复杂度 O(n)。所以，后来才催生了以下实现。</p>
<p><strong>epoll</strong>：2002 年随 Linux 内核 2.5.44 发布，<strong>epoll 能直接返回具体的准备好的通道</strong>，时间复杂度 O(1)。</p>
<p>除了 Linux 中的 epoll，2000 年 FreeBSD 出现了 <strong>Kqueue</strong>，还有就是，Solaris 中有 <strong>/dev/poll</strong>。</p>
<blockquote>
<p>前面说了那么多实现，但是没有出现 Windows，Windows 平台的非阻塞 IO 使用 select，我们也不必觉得 Windows 很落后，在 Windows 中 IOCP 提供的异步 IO 是比较强大的。</p>
</blockquote>
<p>我们回到 Selector，毕竟 JVM 就是这么一个屏蔽底层实现的平台，<strong>我们面向 Selector 编程就可以了</strong>。</p>
<p>之前在介绍 Selector 的时候已经了解过了它的基本用法，这边来一个可运行的实例代码，大家不妨看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取多路复用器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">         <span class="comment">// 将其注册到 Selector 中，监听 OP_ACCEPT 事件</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//在本线程当中进行轮询</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> readyChannels = selector.select();<span class="comment">//会阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 有已经接受的新的到服务端的连接</span></span><br><span class="line">                    SocketChannel socketChannel = server.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有新的连接并不代表这个通道就有数据，</span></span><br><span class="line">                    <span class="comment">// 这里将这个新的 SocketChannel 注册到 Selector，监听 OP_READ 事件，等待数据</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 有数据可读</span></span><br><span class="line">                    <span class="comment">// 上面一个 if 分支中注册了监听 OP_READ 事件的 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                  	<span class="comment">//读取通道当中的数据</span></span><br><span class="line">                    <span class="keyword">int</span> num = socketChannel.read(readBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 处理进来的数据...</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;收到数据：&quot;</span> + <span class="keyword">new</span> String(readBuffer.array()).trim());</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap(<span class="string">&quot;返回给客户端的数据...&quot;</span>.getBytes());</span><br><span class="line">                       <span class="comment">//利用socket通道，把数据写回客户端</span></span><br><span class="line">                      socketChannel.write(buffer);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// -1 代表连接已经关闭</span></span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于客户端，大家可以继续使用上一节介绍阻塞模式时的客户端进行测试。</p>
<h2 id="NIO-2-异步-IO"><a href="#NIO-2-异步-IO" class="headerlink" title="NIO.2 异步 IO"></a>NIO.2 异步 IO</h2><p>More New IO，或称 NIO.2，随 JDK 1.7 发布，包括了<strong>引入异步 IO 接口和 Paths 等文件访问接口</strong>。</p>
<p>异步这个词，我想对于绝大多数开发者来说都很熟悉，很多场景下我们都会使用异步。</p>
<p>通常，我们会<strong>有一个线程池用于执行异步任务</strong>，提交任务的线程将任务提交到线程池就可以立马返回，不必等到任务真正完成。如果想要知道任务的执行结果，通常是通过传递一个回调函数的方式，任务结束后去调用这个函数。</p>
<p>同样的原理，Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p>
<p>大部分开发者都知道为什么要这么设计了，这里再啰嗦一下。<strong>异步 IO 主要是为了控制线程数量，减少过多的线程带来的内存消耗和 CPU 在线程调度上的开销。</strong></p>
<p><strong>在 Unix/Linux 等系统中，JDK 使用了并发包中的线程池来管理任务</strong>，具体可以查看 AsynchronousChannelGroup 的源码。</p>
<p>在 Windows 操作系统中，提供了一个叫做 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx">I/O Completion Ports</a> 的方案，通常简称为 <strong>IOCP</strong>，操作系统负责管理线程池，其性能非常优异，所以<strong>在 Windows 中 JDK 直接采用了 IOCP 的支持</strong>，使用系统支持，把更多的操作信息暴露给操作系统，也使得操作系统能够对我们的 IO 进行一定程度的优化。</p>
<blockquote>
<p>在 Linux 中其实也是有异步 IO 系统实现的，但是限制比较多，性能也一般，所以 JDK 采用了自建线程池的方式。</p>
</blockquote>
<p>本文还是以实用为主，想要了解更多信息请自行查找其他资料，下面对 Java 异步 IO 进行实践性的介绍。</p>
<p>总共有三个类需要我们关注，分别是 <strong>AsynchronousSocketChannel</strong>，<strong>AsynchronousServerSocketChannel</strong> 和 <strong>AsynchronousFileChannel</strong>，只不过是在之前介绍的 FileChannel、SocketChannel 和 ServerSocketChannel 的类名上加了个前缀 <strong>Asynchronous</strong>。</p>
<p>Java 异步 IO 提供了两种使用方式，分别是<strong>返回 Future 实例和使用回调函数</strong>。</p>
<h3 id="返回-Future-实例"><a href="#返回-Future-实例" class="headerlink" title="返回 Future 实例"></a>返回 Future 实例</h3><p>返回 java.util.concurrent.Future 实例的方式我们应该很熟悉，JDK 线程池就是这么使用的。Future 接口的几个方法语义在这里也是通用的，这里先做简单介绍。</p>
<ul>
<li><p>future.isDone();</p>
<p>判断操作是否已经完成，包括了<strong>正常完成、异常抛出、取消</strong></p>
</li>
<li><p>future.cancel(true);</p>
<p>取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断。</p>
</li>
<li><p>future.isCancelled();</p>
<p>是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</p>
</li>
<li><p>future.get();</p>
<p>这是我们的老朋友，获取执行结果，阻塞。</p>
</li>
<li><p>future.get(10, TimeUnit.SECONDS);</p>
<p>如果上面的 get() 方法的阻塞你不满意，那就设置个超时时间。</p>
</li>
</ul>
<h3 id="提供-CompletionHandler-回调"><a href="#提供-CompletionHandler-回调" class="headerlink" title="提供 CompletionHandler 回调"></a>提供 CompletionHandler 回调</h3><p>java.nio.channels.CompletionHandler 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletionHandler</span>&lt;<span class="title">V</span>,<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(V result, A attachment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, A attachment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，参数上有个 attachment，虽然不常用，我们可以在各个支持的方法中传递这个参数值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel listener = AsynchronousServerSocketChannel.open().bind(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accept 方法的第一个参数可以传递 attachment</span></span><br><span class="line">listener.accept(attachment, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      AsynchronousSocketChannel client, Object attachment)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><p>首先，我们就来关注异步的文件 IO，前面我们说了，<strong>文件 IO 在所有的操作系统中都不支持非阻塞模式</strong>，但是我们可以对文件 IO 采用异步的方式来提高性能。</p>
<p>下面，我会介绍 AsynchronousFileChannel 里面的一些重要的接口，都很简单，读者要是觉得无趣，直接滑到下一个标题就可以了。</p>
<p>实例化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;/Users/hongjie/test.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>一旦实例化完成，我们就可以着手准备将数据读入到 Buffer 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">Future&lt;Integer&gt; result = channel.read(buffer, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步文件通道的读操作和写操作都需要提供一个文件的开始位置，文件开始位置为 0</p>
</blockquote>
<p>除了使用返回 Future 实例的方式，也可以采用回调函数进行操作，接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ByteBuffer dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> position,</span></span></span><br><span class="line"><span class="params"><span class="function">                              A attachment,</span></span></span><br><span class="line"><span class="params"><span class="function">                              CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>顺便也贴一下写操作的两个版本的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Future&lt;Integer&gt; <span class="title">write</span><span class="params">(ByteBuffer src, <span class="keyword">long</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ByteBuffer src,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">long</span> position,</span></span></span><br><span class="line"><span class="params"><span class="function">                               A attachment,</span></span></span><br><span class="line"><span class="params"><span class="function">                               CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，AIO 的读写主要也还是与 Buffer 打交道，这个与 NIO 是一脉相承的。</p>
<p>另外，还提供了用于将内存中的数据刷入到磁盘的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为我们对文件的写操作，操作系统并不会直接针对文件操作，系统会缓存，然后周期性地刷入到磁盘。如果希望将数据及时写入到磁盘中，以免断电引发部分数据丢失，可以调用此方法。参数如果设置为 true，意味着同时也将文件属性信息更新到磁盘。</p>
</blockquote>
<p>还有，还提供了对文件的锁定功能，我们可以锁定文件的部分数据，这样可以进行排他性的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Future&lt;FileLock&gt; <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>position 是要锁定内容的开始位置，size 指示了要锁定的区域大小，shared 指示需要的是共享锁还是排他锁</p>
</blockquote>
<p>当然，也可以使用回调函数的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">boolean</span> shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                              A attachment,</span></span></span><br><span class="line"><span class="params"><span class="function">                              CompletionHandler&lt;FileLock,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文件锁定功能上还提供了 tryLock 方法，此方法会快速返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法很简单，就是尝试去获取锁，如果该区域已被其他线程或其他应用锁住，那么立刻返回 null，否则返回 FileLock 对象。</p>
</blockquote>
<p>AsynchronousFileChannel 操作大体上也就以上介绍的这些接口，还是比较简单的，这里就少一些废话早点结束好了。</p>
<h3 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h3><p>这个类对应的是非阻塞 IO 的 ServerSocketChannel，大家可以类比下使用方式。</p>
<p>我们就废话少说，用代码说事吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 实例化，并监听端口</span></span><br><span class="line">        AsynchronousServerSocketChannel server =</span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己定义一个 Attachment 类，用于传递一些信息</span></span><br><span class="line">        Attachment att = <span class="keyword">new</span> Attachment();</span><br><span class="line">        att.setServer(server);</span><br><span class="line"></span><br><span class="line">        server.accept(att, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Attachment&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, Attachment att)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketAddress clientAddr = client.getRemoteAddress();</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到新的连接：&quot;</span> + clientAddr);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收到新的连接后，server 应该重新调用 accept 方法等待新的连接进来</span></span><br><span class="line">                    att.getServer().accept(att, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Attachment newAtt = <span class="keyword">new</span> Attachment();</span><br><span class="line">                    newAtt.setServer(server);</span><br><span class="line">                    newAtt.setClient(client);</span><br><span class="line">                    newAtt.setReadMode(<span class="keyword">true</span>);</span><br><span class="line">                    newAtt.setBuffer(ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这里也可以继续使用匿名实现类，不过代码不好看，所以这里专门定义一个类</span></span><br><span class="line">                  	<span class="comment">//从通道当中异步读取数据</span></span><br><span class="line">                    client.read(newAtt.getBuffer(), newAtt, <span class="keyword">new</span> ChannelHandler());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable t, Attachment att)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 为了防止 main 线程退出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 ChannelHandler 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Attachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Attachment att)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自客户端的数据</span></span><br><span class="line">            ByteBuffer buffer = att.getBuffer();</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">byte</span> bytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            String msg = <span class="keyword">new</span> String(buffer.array()).toString().trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自客户端的数据: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应客户端请求，返回数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(<span class="string">&quot;Response from server!&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">            att.setReadMode(<span class="keyword">false</span>);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 写数据到客户端也是异步</span></span><br><span class="line">            att.getClient().write(buffer, att, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明往客户端写数据也结束了，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1. 继续等待客户端发送新的数据过来</span></span><br><span class="line"><span class="comment">//            att.setReadMode(true);</span></span><br><span class="line"><span class="comment">//            att.getBuffer().clear();</span></span><br><span class="line"><span class="comment">//            att.getClient().read(att.getBuffer(), att, this);</span></span><br><span class="line">            <span class="comment">// 2. 既然服务端已经返回数据给客户端，断开这次的连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable t, Attachment att)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便再贴一下自定义的 Attachment 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isReadMode;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer;</span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个简单的服务端就写好了，接下来可以接收客户端请求了。上面我们用的都是回调函数的方式，读者要是感兴趣，可以试试写个使用 Future 的。</p>
<h3 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h3><p>其实，说完上面的 AsynchronousServerSocketChannel，基本上读者也就知道怎么使用 AsynchronousSocketChannel 了，和非阻塞 IO 基本类似。</p>
<p>这边做个简单演示，这样读者就可以配合之前介绍的 Server 进行测试使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">          <span class="comment">// 来个 Future 形式的</span></span><br><span class="line">        Future&lt;?&gt; future = client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 阻塞一下，等待连接成功</span></span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        Attachment att = <span class="keyword">new</span> Attachment();</span><br><span class="line">        att.setClient(client);</span><br><span class="line">        att.setReadMode(<span class="keyword">false</span>);</span><br><span class="line">        att.setBuffer(ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">&quot;I am obot!&quot;</span>.getBytes();</span><br><span class="line">        att.getBuffer().put(data);</span><br><span class="line">        att.getBuffer().flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送数据到服务端</span></span><br><span class="line">        client.write(att.getBuffer(), att, <span class="keyword">new</span> ClientChannelHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里休息一下再退出，给出足够的时间处理数据</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>往里面看下 ClientChannelHandler 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Attachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Attachment att)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = att.getBuffer();</span><br><span class="line">        <span class="keyword">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自服务端的数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            String msg = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自服务端的响应数据: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1. 向服务端发送新的数据</span></span><br><span class="line"><span class="comment">//            att.setReadMode(false);</span></span><br><span class="line"><span class="comment">//            buffer.clear();</span></span><br><span class="line"><span class="comment">//            String newMsg = &quot;new message from client&quot;;</span></span><br><span class="line"><span class="comment">//            byte[] data = newMsg.getBytes(Charset.forName(&quot;UTF-8&quot;));</span></span><br><span class="line"><span class="comment">//            buffer.put(data);</span></span><br><span class="line"><span class="comment">//            buffer.flip();</span></span><br><span class="line"><span class="comment">//            att.getClient().write(buffer, att, this);</span></span><br><span class="line">            <span class="comment">// 2. 关闭连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 写操作完成后，会进到这里</span></span><br><span class="line">            att.setReadMode(<span class="keyword">true</span>);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            att.getClient().read(buffer, att, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable t, Attachment att)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器无响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码都是可以运行调试的，如果读者碰到问题，请在评论区留言。</p>
<h3 id="Asynchronous-Channel-Groups"><a href="#Asynchronous-Channel-Groups" class="headerlink" title="Asynchronous Channel Groups"></a>Asynchronous Channel Groups</h3><p>为了知识的完整性，有必要对 group 进行介绍，其实也就是介绍 AsynchronousChannelGroup 这个类。之前我们说过，异步 IO 一定存在一个线程池，这个线程池负责接收任务、处理 IO 事件、回调等。这个线程池就在 group 内部，group 一旦关闭，那么相应的线程池就会关闭。</p>
<p>AsynchronousServerSocketChannels 和 AsynchronousSocketChannels 是属于 group 的，当我们调用 AsynchronousServerSocketChannel 或 AsynchronousSocketChannel 的 open() 方法的时候，相应的 channel 就属于默认的 group，这个 group 由 JVM 自动构造并管理。</p>
<p>如果我们想要配置这个默认的 group，可以在 JVM 启动参数中指定以下系统变量：</p>
<ul>
<li><p>java.nio.channels.DefaultThreadPool.threadFactory</p>
<p>此系统变量用于设置 ThreadFactory，它应该是 java.util.concurrent.ThreadFactory 实现类的全限定类名。一旦我们指定了这个 ThreadFactory 以后，group 中的线程就会使用该类产生。</p>
</li>
<li><p>java.nio.channels.DefaultThreadPool.initialSize</p>
<p>此系统变量也很好理解，用于设置线程池的初始大小。</p>
</li>
</ul>
<p>可能你会想要使用自己定义的 group，这样可以对其中的线程进行更多的控制，使用以下几个方法即可：</p>
<ul>
<li>AsynchronousChannelGroup.withCachedThreadPool(ExecutorService executor, int initialSize)</li>
<li>AsynchronousChannelGroup.withFixedThreadPool(int nThreads, ThreadFactory threadFactory)</li>
<li>AsynchronousChannelGroup.withThreadPool(ExecutorService executor)</li>
</ul>
<p>熟悉线程池的读者对这些方法应该很好理解，它们都是 AsynchronousChannelGroup 中的静态方法。</p>
<p>至于 group 的使用就很简单了，代码一看就懂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousChannelGroup group = AsynchronousChannelGroup</span><br><span class="line">        .withFixedThreadPool(<span class="number">10</span>, Executors.defaultThreadFactory());</span><br><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group);</span><br><span class="line">AsynchronousSocketChannel client = AsynchronousSocketChannel.open(group);</span><br></pre></td></tr></table></figure>

<p><strong>AsynchronousFileChannels 不属于 group</strong>。但是它们也是关联到一个线程池的，如果不指定，会使用系统默认的线程池，如果想要使用指定的线程池，可以在实例化的时候使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsynchronousFileChannel <span class="title">open</span><span class="params">(Path file,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Set&lt;? extends OpenOption&gt; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ExecutorService executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           FileAttribute&lt;?&gt;... attrs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，异步 IO 就算介绍完成了。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我想，本文应该是说清楚了非阻塞 IO 和异步 IO 了，对于异步 IO，由于网上的资料比较少，所以不免篇幅多了些。</p>
<p>我们也要知道，看懂了这些，确实可以学到一些东西，多了解一些知识，但是我们还是很少在工作中将这些知识变成工程代码。一般而言，我们需要在网络应用中使用 NIO 或 AIO 来提升性能，但是，在工程上，绝不是了解了一些概念，知道了一些接口就可以的，需要处理的细节还非常多。</p>
<p>这也是为什么 Netty/Mina 如此盛行的原因，因为它们帮助封装好了很多细节，提供给我们用户友好的接口，后面有时间我也会对 Netty 进行介绍。</p>
<h1 id="Tomcat-中的-NIO-源码分析"><a href="#Tomcat-中的-NIO-源码分析" class="headerlink" title="Tomcat 中的 NIO 源码分析"></a>Tomcat 中的 NIO 源码分析</h1><p>之前写了两篇关于 NIO 的文章，第一篇介绍了 NIO 的 Channel、Buffer、Selector 使用，第二篇介绍了非阻塞 IO 和异步 IO，并展示了简单的用例。</p>
<p>本文将介绍 Tomcat 中的 NIO 使用，使大家对 Java NIO 的生产使用有更加直观的认识。</p>
<p>虽然本文的源码篇幅也不短，但是 Tomcat 的源码毕竟不像 Doug Lea 的并发源码那么“变态”，对于大部分读者来说，阅读难度比之前介绍的其他并发源码要简单一些，所以读者不要觉得有什么压力。</p>
<p>本文基于 Tomcat 当前（2018-03-20）<strong>最新版本 9.0.6</strong>。</p>
<p>先简单画一张图示意一下本文的主要内容：</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/0-20190523142142854.png" alt="0"></p>
<h2 id="源码环境准备"><a href="#源码环境准备" class="headerlink" title="源码环境准备"></a>源码环境准备</h2><p>由于上面下载的 tomcat 的源码并没有使用 maven 进行组织，不方便我们看源码，也不方便我们进行调试。这里我们将使用 maven 仓库中的 tomcat-embed-core，自己编写代码进行启动的方式来进行调试。</p>
<p>首先，创建一个空的 maven 工程，然后添加以下依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的依赖，只会将 tomcat-embed-core-9.0.6.jar 和 tomcat-annotations-api-9.0.6.jar 两个包引进来，对于本文来说，已经足够了，如果你需要其他功能，需要额外引用其他的依赖，如 Jasper。</p>
</blockquote>
<p>然后，使用以下启动方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line"></span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="string">&quot;HTTP/1.1&quot;</span>);</span><br><span class="line">   connector.setPort(<span class="number">8080</span>);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line"></span><br><span class="line">   tomcat.start();</span><br><span class="line">   tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上的代码，我们的 Tomcat 就启动起来了。</p>
<blockquote>
<p>Tomcat 中的其他接口感兴趣的读者请自行探索，如设置 webapp 目录，设置 resources 等</p>
</blockquote>
<p>这里，介绍第一个重要的概念：<strong>Connector</strong>。在 Tomcat 中，使用 Connector 来处理连接，一个 Tomcat 可以配置多个 Connector，分别用于监听不同端口，或处理不同协议。</p>
<p>在 Connector 的构造方法中，我们可以传 <code>HTTP/1.1</code> 或 <code>AJP/1.3</code> 用于指定协议，也可以传入相应的协议处理类，毕竟协议不是重点，将不同端口进来的连接对应不同处理类才是正道。典型地，我们可以指定以下几个协议处理类：</p>
<ul>
<li>org.apache.coyote.http11.Http11NioProtocol：对应非阻塞 IO</li>
<li>org.apache.coyote.http11.Http11Nio2Protocol：对应异步 IO</li>
<li>org.apache.coyote.http2.Http2Protocol：对应 http2 协议，对 http2 感兴趣的读者，赶紧看起来吧。</li>
</ul>
<p><del>本文的重点当然是非阻塞 IO 了，之前已经介绍过<code>异步 IO</code>的基础知识了，读者看完本文后，如果对异步 IO 的处理流程感兴趣，可以自行去分析一遍。</del></p>
<blockquote>
<p>如果你使用 9.0 以前的版本，Tomcat 在启动的时候是会自动配置一个 connector 的，我们可以不用显示配置。</p>
<p>9.0 版本的 Tomcat#start() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    getServer();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.5 及之前版本的 Tomcat#start() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    getServer();</span><br><span class="line">    <span class="comment">// 自动配置一个使用非阻塞 IO 的 connector</span></span><br><span class="line">    getConnector();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>前面我们说过一个 Connector 对应一个协议，当然这描述也不太对，NIO 和 NIO2 就都是处理 HTTP/1.1 的，只不过一个使用非阻塞，一个使用异步。进到指定 protocol 代码，我们就会发现，它们的代码及其简单，只不过是指定了特定的 <strong>endpoint</strong>。</p>
<p>打开 <code>Http11NioProtocol</code> 和 <code>Http11Nio2Protocol</code>源码，我们可以看到，在构造方法中，它们分别指定了 NioEndpoint 和 Nio2Endpoint。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Http11NioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NioEndpoint</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11Nio2Protocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">Nio2Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Http11Nio2Protocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Nio2Endpoint</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> Nio2Endpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里介绍第二个重要的概念：<strong>endpoint</strong>。Tomcat 使用不同的 endpoint 来处理不同的协议请求，今天我们的重点是 <strong>NioEndpoint</strong>，其使用<strong>非阻塞 IO</strong> 来进行处理 HTTP/1.1 协议的请求。</p>
<p><strong>NioEndpoint</strong> 继承 =&gt; <strong>AbstractJsseEndpoint</strong> 继承 =&gt; <strong>AbstractEndpoint</strong>。中间的 AbstractJsseEndpoint 主要是提供了一些关于 <code>HTTPS</code> 的方法，这块我们暂时忽略它，后面所有关于 HTTPS 的我们都直接忽略，感兴趣的读者请自行分析。</p>
<h2 id="init-过程分析"><a href="#init-过程分析" class="headerlink" title="init 过程分析"></a>init 过程分析</h2><p>下面，我们看看从 tomcat.start() 一直到 NioEndpoint 的过程。</p>
<p><strong>1. AbstractProtocol</strong> # <strong>init</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line">    <span class="comment">// endpoint 的 name=http-nio-8089,domain=Tomcat</span></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. AbstractEndpoint</strong> # <strong>init</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bind(); <span class="comment">// 这里对应的当然是子类 NioEndpoint 的 bind() 方法</span></span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. NioEndpoint</strong> # <strong>bind</strong></p>
<p>这里就到我们的 NioEndpoint 了，要使用到我们之前学习的 NIO 的知识了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// initServerSocket(); 原代码是这行，我们 “内联” 过来一起说</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 ServerSocketChannel</span></span><br><span class="line">    serverSock = ServerSocketChannel.open();</span><br><span class="line">    socketProperties.setProperties(serverSock.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getPort() 会返回我们最开始设置的 8080，得到我们的 address 是 0.0.0.0:8080</span></span><br><span class="line">    InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServerSocketChannel 绑定地址、端口，</span></span><br><span class="line">    <span class="comment">// 第二个参数 backlog 默认为 100，超过 100 的时候，新连接会被拒绝(不过源码注释也说了，这个值的真实语义取决于具体实现)</span></span><br><span class="line">    serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ※※※ 设置 ServerSocketChannel 为阻塞模式 ※※※</span></span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 acceptor 和 poller 的数量，至于它们是什么角色，待会说</span></span><br><span class="line">    <span class="comment">// acceptorThreadCount 默认为 1</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">        <span class="comment">// 作者想表达的意思应该是：使用多个 acceptor 线程并不见得性能会更好</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poller 线程数，默认值定义如下，所以在多核模式下，默认为 2</span></span><br><span class="line">    <span class="comment">// pollerThreadCount = Math.min(2,Runtime.getRuntime().availableProcessors());</span></span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ssl，我们忽略 ssl</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 NioSelectorPool，先忽略它</span></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>ServerSocketChannel 已经打开，并且绑定要了之前指定的 8080 端口，设置成了<strong>阻塞模式</strong>。</li>
<li>设置了 acceptor 的线程数为 1</li>
<li>设置了 poller 的线程数，单核 CPU 为 1，多核为 2</li>
<li>打开了一个 SelectorPool，我们先忽略这个</li>
</ol>
<p>到这里，我们还不知道 Acceptor 和 Poller 是什么东西，我们只是设置了它们的数量，我们先来看看最后面提到的 SelectorPool。</p>
<h2 id="start-过程分析"><a href="#start-过程分析" class="headerlink" title="start 过程分析"></a>start 过程分析</h2><p>刚刚我们分析完了 init() 过程，下面是启动过程 start() 分析。</p>
<p>AbstractProtocol # start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用 endpoint 的 start 方法</span></span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start async timeout thread</span></span><br><span class="line">    asyncTimeout = <span class="keyword">new</span> AsyncTimeout();</span><br><span class="line">    Thread timeoutThread = <span class="keyword">new</span> Thread(asyncTimeout, getNameInternal() + <span class="string">&quot;-AsyncTimeout&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> priority = endpoint.getThreadPriority();</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = Thread.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractEndpoint # start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 按照我们的流程，刚刚 init 的时候，已经把 bindState 改为 BindState.BOUND_ON_INIT 了，</span></span><br><span class="line">    <span class="comment">// 所以下面的 if 分支我们就不进去了</span></span><br><span class="line">    <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往里看 NioEndpoint 的实现</span></span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个方法还是比较重要的，这里会创建前面说过的 acceptor 和 poller。</p>
<p>NioEndpoint # startInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下几个是缓存用的，之后我们也会看到很多这样的代码，为了减少 new 很多对象出来</span></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建【工作线程池】，Tomcat 自己包装了一下 ThreadPoolExecutor，</span></span><br><span class="line">        <span class="comment">// 1. 为了在创建线程池以后，先启动 corePoolSize 个线程(这个属于线程池的知识了，不熟悉的读者可以看看我之前的文章)</span></span><br><span class="line">        <span class="comment">// 2. 自己管理线程池的增长方式（默认 corePoolSize 10, maxPoolSize 200），不是本文重点，不分析</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置一个栅栏（tomcat 自定义了类 LimitLatch），控制最大的连接数，默认是 10000</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启 poller 线程</span></span><br><span class="line">        <span class="comment">// 还记得之前 init 的时候，默认地设置了 poller 的数量为 2，所以这里启动 2 个 poller 线程</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poler();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启 acceptor 线程，和开启 poller 线程组差不多。</span></span><br><span class="line">        <span class="comment">// init 的时候，默认地，acceptor 的线程数是 1</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们启动了<strong>工作线程池</strong>、 <strong>poller 线程组</strong>、<strong>acceptor 线程组</strong>。同时，工作线程池初始就已经启动了 10 个线程。我们用 <strong>jconsole</strong> 来看看此时的线程，请看下图：</p>
<p><img src="/techSnapshot.github.io/2021/07/23/Java-NIO/1-8592503.png" alt="1"></p>
<p>从 jconsole 中，我们可以看到，此时启动了 BlockPoller、worker、poller、acceptor、AsyncTimeout，大家应该都已经清楚了每个线程是哪里启动的吧。</p>
<blockquote>
<p>Tomcat 中并没有 Worker 这个类，此名字是我瞎编。</p>
</blockquote>
<p>此时，我们还是不知道 acceptor、poller 甚至 worker 到底是干嘛的，下面，我们从 acceptor 线程开始看起。</p>
<h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>它的结构非常简单，在构造函数中，已经把 endpoint 传进来了，此外就只有 threadName 和 state 两个简单的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractEndpoint&lt;?,U&gt; endpoint;</span><br><span class="line"><span class="keyword">private</span> String threadName;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(AbstractEndpoint&lt;?,U&gt; endpoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>threadName</strong> 就是一个线程名字而已，Acceptor 的状态 <strong>state</strong> 主要是随着 endpoint 来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AcceptorState</span> </span>&#123;</span><br><span class="line">    NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接来看 acceptor 的 run 方法吧：</p>
<p>Acceptor # run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 endpoint 处于 running，这里就一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (endpoint.isRunning()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 endpoint 处于 pause 状态，这边 Acceptor 用一个 while 循环将自己也挂起</span></span><br><span class="line">        <span class="keyword">while</span> (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">            state = AcceptorState.PAUSED;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endpoint 结束了，Acceptor 自然也要结束嘛</span></span><br><span class="line">        <span class="keyword">if</span> (!endpoint.isRunning()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果此时达到了最大连接数(之前我们说过，默认是10000)，就等待</span></span><br><span class="line">            endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Endpoint might have been paused while waiting for latch</span></span><br><span class="line">            <span class="comment">// If that is the case, don&#x27;t accept new connections</span></span><br><span class="line">            <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里就是接收下一个进来的 SocketChannel</span></span><br><span class="line">                <span class="comment">// 之前我们设置了 ServerSocketChannel 为阻塞模式，所以这边的 accept 是阻塞的</span></span><br><span class="line">                socket = endpoint.serverSocketAccept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                <span class="comment">// We didn&#x27;t get a socket</span></span><br><span class="line">                endpoint.countDownConnection();</span><br><span class="line">                <span class="keyword">if</span> (endpoint.isRunning()) &#123;</span><br><span class="line">                    <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                    errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                    <span class="comment">// re-throw</span></span><br><span class="line">                    <span class="keyword">throw</span> ioe;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// accept 成功，将 errorDelay 设置为 0</span></span><br><span class="line">            errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                <span class="comment">// setSocketOptions() 是这里的关键方法，也就是说前面千辛万苦都是为了能到这里进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                    <span class="comment">// 如果上面的方法返回 false，关闭 SocketChannel</span></span><br><span class="line">                    endpoint.closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于 endpoint 不 running 了，或者处于 pause 了，将此 SocketChannel 关闭</span></span><br><span class="line">                endpoint.destroySocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            String msg = sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>);</span><br><span class="line">            <span class="comment">// APR specific.</span></span><br><span class="line">            <span class="comment">// Could push this down but not sure it is worth the trouble.</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                Error e = (Error) t;</span><br><span class="line">                <span class="keyword">if</span> (e.getError() == <span class="number">233</span>) &#123;</span><br><span class="line">                    <span class="comment">// Not an error on HP-UX so log as a warning</span></span><br><span class="line">                    <span class="comment">// so it can be filtered out on that platform</span></span><br><span class="line">                    <span class="comment">// See bug 50273</span></span><br><span class="line">                    log.warn(msg, t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(msg, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家应该发现了，Acceptor 绕来绕去，都是在调用 NioEndpoint 的方法，我们简单分析一下这个。</p>
<p>在 NioEndpoint init 的时候，我们开启了一个 ServerSocketChannel，后来 start 的时候，我们开启多个 acceptor（实际上，默认是 1 个，多核则为2个），每个 acceptor 启动以后就开始循环调用 ServerSocketChannel 的 accept() 方法获取新的连接，然后调用 endpoint.setSocketOptions(socket) 处理新的连接，之后再进入循环 accept 下一个连接。</p>
<p>到这里，大家应该也就知道了，为什么这个叫 acceptor 了吧？接下来，我们来看看 setSocketOptions 方法到底做了什么。</p>
<p>NioEndpoint # setSocketOptions</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置该 SocketChannel 为非阻塞模式</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        <span class="comment">// 设置 socket 的一些属性</span></span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还记得 startInternal 的时候，说过了 nioChannels 是缓存用的。</span></span><br><span class="line">        <span class="comment">// 限于篇幅，这里的 NioChannel 就不展开了，它包括了 socket 和 buffer</span></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 主要是创建读和写的两个 buffer，默认地，读和写 buffer 都是 8192 字节，8k</span></span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getPoller0() 会选取所有 poller 中的一个 poller</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，这里又没有进行实际的处理，而是将这个 SocketChannel <strong>注册</strong>到了其中一个 poller 上。因为我们知道，<strong>acceptor 应该尽可能的简单</strong>，只做 accept 的工作，简单处理下就往后面扔。acceptor 还得回到之前的循环去 accept 新的连接呢。</p>
<p>我们只需要明白，此时，往 poller 中注册了一个 NioChannel 实例，此实例包含客户端过来的 SocketChannel 和一个 SocketBufferHandler 实例。</p>
<h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>之前我们看到 acceptor 将一个 NioChannel 实例 register 到了一个 poller 中。在看 register 方法之前，我们需要先对 poller 要有个简单的认识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 每个 poller 开启一个 Selector</span></span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// events 队列，此类的核心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">            <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextExpiration = <span class="number">0</span>;<span class="comment">//optimize expiration handling</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个值后面有用，记住它的初始值为 0</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong wakeupCounter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>敲重点：每个 poller 关联了一个 Selector。</p>
</blockquote>
<p>Poller 内部围着一个 events 队列转，来看看其 events() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 逐个执行 event.run()</span></span><br><span class="line">            pe.run();</span><br><span class="line">            <span class="comment">// 该 PollerEvent 还得给以后用，这里 reset 一下(还是之前说过的缓存)</span></span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events() 方法比较简单，就是取出当前队列中的 PollerEvent 对象，逐个执行 event.run() 方法。</p>
<p>然后，现在来看 Poller 的 run() 方法，该方法会一直循环，直到 poller.destroy() 被调用。</p>
<p>Poller # run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                <span class="comment">// 执行 events 队列中每个 event 的 run() 方法</span></span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="comment">// wakeupCounter 的初始值为 0，这里设置为 -1</span></span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                    <span class="comment">//do a non blocking select</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// timeout 默认值 1 秒</span></span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 篇幅所限，我们就不说 close 的情况了</span></span><br><span class="line">            <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                events();</span><br><span class="line">                timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">&quot;endpoint.nio.selectorCloseFail&quot;</span>), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">        <span class="comment">// 这里没什么好说的，顶多就再执行一次 events() 方法</span></span><br><span class="line">        <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果刚刚 select 有返回 ready keys，进行处理</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">            keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">        <span class="comment">// any active event.</span></span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">            <span class="comment">// cancelledKey()</span></span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// ※※※※※ 处理 ready key ※※※※※</span></span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//process timeouts</span></span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poller 的 run() 方法主要做了调用 events() 方法和处理注册到 Selector 上的 ready key，这里我们暂时不展开 processKey 方法，因为此方法必定是及其复杂的。</p>
<p>我们回过头来看之前从 acceptor 线程中调用的 register 方法。</p>
<p>Poller # register</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">    socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line"></span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意第三个参数值 OP_REGISTER</span></span><br><span class="line">    <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 event 到 poller 中</span></span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将这个 socket（包含 socket 和 buffer 的 NioChannel 实例） 包装为一个 PollerEvent，然后添加到 events 中，此时调用此方法的 acceptor 结束返回，去处理新的 accepted 连接了。</p>
<p>接下来，我们已经知道了，poller 线程在循环过程中会不断调用 events() 方法，那么 PollerEvent 的 run() 方法很快就会被执行，我们就来看看刚刚这个新的连接被<strong>注册</strong>到这个 poller 后，会发生什么。</p>
<p>PollerEvent # run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于新来的连接，前面我们说过，interestOps == OP_REGISTER</span></span><br><span class="line">    <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这步很关键！！！</span></span><br><span class="line">            <span class="comment">// 将这个新连接 SocketChannel 注册到该 poller 的 Selector 中，</span></span><br><span class="line">            <span class="comment">// 设置监听 OP_READ 事件，</span></span><br><span class="line">            <span class="comment">// 将 socketWrapper 设置为 attachment 进行传递(这个对象可是什么鬼都有，往上看就知道了)</span></span><br><span class="line">            socket.getIOChannel().register(</span><br><span class="line">                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;endpoint.nio.registerFail&quot;</span>), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* else 这块不介绍，省得大家头大 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The key was cancelled (e.g. due to socket closure)</span></span><br><span class="line">                <span class="comment">// and removed from the selector while it was being</span></span><br><span class="line">                <span class="comment">// processed. Count down the connections at this point</span></span><br><span class="line">                <span class="comment">// since it won&#x27;t have been counted down when the socket</span></span><br><span class="line">                <span class="comment">// closed.</span></span><br><span class="line">                socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></span><br><span class="line">                    <span class="keyword">int</span> ops = key.interestOps() | interestOps;</span><br><span class="line">                    socketWrapper.interestOps(ops);</span><br><span class="line">                    key.interestOps(ops);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getPoller().cancelledKey(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们再回顾一下：刚刚在 PollerEvent 的 run() 方法中，我们看到，新的 SocketChannel 注册到了 Poller 内部的 Selector 中，监听 OP_READ 事件，然后我们再回到 Poller 的 run() 看下，一旦该 SocketChannel 是 readable 的状态，那么就会进入到 poller 的 processKey 方法。</p>
<h2 id="processKey"><a href="#processKey" class="headerlink" title="processKey"></a>processKey</h2><p>Poller # processKey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="comment">// 忽略 sendfile</span></span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// unregister 相应的 interest set，</span></span><br><span class="line">                    <span class="comment">// 如接下来是处理 SocketChannel 进来的数据，那么就不再监听该 channel 的 OP_READ 事件</span></span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// Read goes before write</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理读</span></span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理写</span></span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是 processSocket 方法，注意第三个参数，上面进来的时候是 true。</p>
<p>AbstractEndpoint # processSocket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="params"><span class="function">        SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个 SocketProcessor 的实例</span></span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将任务放到之前建立的 worker 线程池中执行</span></span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run(); <span class="comment">// ps: 如果 dispatch 为 false，那么就当前线程自己执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">        <span class="comment">// the pool and its queue are full</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">&quot;endpoint.process.fail&quot;</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioEndpoint # createSocketProcessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SocketProcessorBase&lt;NioChannel&gt; <span class="title">createSocketProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SocketProcessor(socketWrapper, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，提交到 worker 线程池中的是 NioEndpoint.SocketProcessor 的实例，至于它的 run() 方法之后的逻辑，我们就不再继续往里分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，再祭出文章开始的那张图来总结一下：</p>
<p><img src="https://www.javadoop.com/blogimages/tomcat-nio/0.png" alt="0"></p>
<p>这里简单梳理下前面我们说的流程，帮大家回忆一下：</p>
<ol>
<li>指定 Protocol，初始化相应的 Endpoint，我们分析的是 NioEndpoint；</li>
<li>init 过程：在 NioEndpoint 中做 bind 操作；</li>
<li>start 过程：启动 worker 线程池，启动 1 个 Acceptor 和 2 个 Poller，当然它们都是默认值，可配；</li>
<li>Acceptor 获取到新的连接后，getPoller0() 获取其中一个 Poller，然后 register 到 Poller 中；</li>
<li>Poller 循环 selector.select(xxx)，如果有通道 readable，那么在 processKey 中将其放到 worker 线程池中。</li>
</ol>
<p>后续的流程，感兴趣的读者请自行分析，本文就说到这里了。</p>
<h1 id="IO和NIO的选择"><a href="#IO和NIO的选择" class="headerlink" title="IO和NIO的选择"></a>IO和NIO的选择</h1><p>IO和NIO的区别主要体现在：</p>
<table>
<thead>
<tr>
<th><strong>IO</strong></th>
<th><strong>NIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Stream oriented</td>
<td>Buffer oriented</td>
</tr>
<tr>
<td>Blocking IO</td>
<td>Non blocking IO</td>
</tr>
<tr>
<td></td>
<td>Selectors</td>
</tr>
</tbody></table>
<p>IO面向Stream，每次读取一定数量的字节，并且不能在流中的数据中来回移动。如果需要来回移动从流读取的数据，则需要首先将其缓存到缓冲区中。</p>
<p>NIO面向Buffer，每次读取一定数量的数据进入缓冲区，可以通过操纵缓冲区来处理数据。这增加了一些灵活性，但是同时也增加了一些数据处理的复杂度，因为需要知道缓冲区当中是否存有全部的数据并且要保证缓冲区数据的正确性。</p>
<p>IO是阻塞式的读写方式，这就意味着每次读写操作未完成的时候，线程会阻塞在那里等待，什么也干不了，直到数据读写完毕。</p>
<p>NIO则是非阻塞的读写方式，每次从通道进行数据读取的时候，有数据就读，没数据就返回，完全不会阻塞线程。这就意味着，我们没法在一次读写之后，确定缓冲区当中的数据是否是全部想要读取的数据。</p>
<p>NIO通过Selector增加了对IO多路复用的支持，可以将不同的通道注册到Selector上，然后在一条单线程当中通过轮询的方式查看是否有准备好的通道可供读写。</p>
<p>因此，</p>
<p>NIO允许您仅使用一个(或几个)线程管理多个通道(网络连接或文件)，但代价是解析数据可能比从阻塞流读取数据要复杂一些。</p>
<p>如果需要同时管理数千个打开的连接(每个连接只发送少量数据，例如聊天服务器)，那么在NIO中实现服务器可能是一个优势。类似地，如果您需要保持与其他计算机的大量开放连接，例如在P2P网络中，使用一个线程管理所有出站连接可能是一个优势。</p>
<p>如果您有非常高带宽的少量连接，一次发送大量数据，那么经典的IO服务器实现可能是最佳选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Mysql最小知识集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-22 15:07:02 / 修改时间：15:19:03" itemprop="dateCreated datePublished" datetime="2021-07-22T15:07:02+08:00">2021-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Mysql架构设计(SQL接口、查询解析器、查询优化器、存储引擎、执行器)</li>
<li>Mysql日志相关(undo log、redo log、binlog)</li>
<li>Innodb存储引擎(buffer pool结构、free链表作用、flush链表作用、lru链表作用)</li>
<li>Mysql数据页/数据行/表空间/数据区</li>
<li>Mysql事务隔离级别/MVCC机制原理</li>
<li>索引原理/索引规则/索引优化</li>
<li>Explain执行计划分析</li>
</ol>
<h2 id="MySQL整体架构"><a href="#MySQL整体架构" class="headerlink" title="MySQL整体架构"></a>MySQL整体架构</h2><h3 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210506063443484.png" alt="image-20210506063443484" style="zoom:50%;">

<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210506063106059.png" alt="image-20210506063106059"></p>
<h3 id="生产经验"><a href="#生产经验" class="headerlink" title="生产经验"></a>生产经验</h3><h4 id="开发前期，与数据库紧密相关的准备工作"><a href="#开发前期，与数据库紧密相关的准备工作" class="headerlink" title="开发前期，与数据库紧密相关的准备工作"></a>开发前期，与数据库紧密相关的准备工作</h4><p>通过本小节，去大致的了解正规的互联网公司在开发前期，需要做哪些与数据库相关的准备工作</p>
<h4 id="数据库机器配置的选择"><a href="#数据库机器配置的选择" class="headerlink" title="数据库机器配置的选择"></a>数据库机器配置的选择</h4><h2 id="插曲：学习大纲"><a href="#插曲：学习大纲" class="headerlink" title="插曲：学习大纲"></a>插曲：学习大纲</h2><p>假设手上有了一个经过压测的、有了完善的监控系统的数据库开始，然后按照在在日常开发一个系统的流程当中使用数据库的顺序进行学习。</p>
<ol>
<li>增删改查的幕后原理，以及事务原理包括锁的底层机制</li>
<li>执行复杂查询时候，涉及到的索引底层原理，查询优化的底层原理</li>
<li>平时开发系统的时候，应该如何进行数据库建模，在数据库建模的时候应该如何注意字段类型、索引类型，如何保证数据库避免死锁高性能的运行</li>
<li>高阶的数据库架构设计<ol>
<li>主从架构设计</li>
<li>分库分表架构设计</li>
</ol>
</li>
</ol>
<p>在这个过程中会穿插着一些生产实践相关案例，这些也是非常宝贵的过来人的经验，要好好吸取。</p>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><h3 id="2-1-Buffer-Pool内存数据结构"><a href="#2-1-Buffer-Pool内存数据结构" class="headerlink" title="2.1 Buffer Pool内存数据结构"></a>2.1 Buffer Pool内存数据结构</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509075305294.png" alt="image-20210509075305294" style="zoom:50%;">

<h4 id="如何配置Buffer-Pool的大小"><a href="#如何配置Buffer-Pool的大小" class="headerlink" title="如何配置Buffer Pool的大小"></a>如何配置Buffer Pool的大小</h4><h4 id="数据页：MySQL中抽象出来的数据单位"><a href="#数据页：MySQL中抽象出来的数据单位" class="headerlink" title="数据页：MySQL中抽象出来的数据单位"></a>数据页：MySQL中抽象出来的数据单位</h4><h4 id="磁盘上的数据页与Buffer-Pool中的缓存页是如何对应起来的"><a href="#磁盘上的数据页与Buffer-Pool中的缓存页是如何对应起来的" class="headerlink" title="磁盘上的数据页与Buffer Pool中的缓存页是如何对应起来的"></a>磁盘上的数据页与Buffer Pool中的缓存页是如何对应起来的</h4><h4 id="缓存页中的描述信息是什么"><a href="#缓存页中的描述信息是什么" class="headerlink" title="缓存页中的描述信息是什么"></a>缓存页中的描述信息是什么</h4><h4 id="思考：关于Buffer-Pool中的内存碎片"><a href="#思考：关于Buffer-Pool中的内存碎片" class="headerlink" title="思考：关于Buffer Pool中的内存碎片"></a>思考：关于Buffer Pool中的内存碎片</h4><h3 id="2-2-free链表"><a href="#2-2-free链表" class="headerlink" title="2.2 free链表"></a>2.2 free链表</h3><h4 id="buffer-pool是如何被初始化的"><a href="#buffer-pool是如何被初始化的" class="headerlink" title="buffer pool是如何被初始化的"></a>buffer pool是如何被初始化的</h4><h4 id="如何知道哪些缓存页是空闲的"><a href="#如何知道哪些缓存页是空闲的" class="headerlink" title="如何知道哪些缓存页是空闲的"></a>如何知道哪些缓存页是空闲的</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509075623705.png" alt="image-20210509075623705" style="zoom:50%;">

<h4 id="free链表占多少内存空间"><a href="#free链表占多少内存空间" class="headerlink" title="free链表占多少内存空间"></a>free链表占多少内存空间</h4><h4 id="如何将磁盘上的页读到Buffer-Pool的缓存页里边去"><a href="#如何将磁盘上的页读到Buffer-Pool的缓存页里边去" class="headerlink" title="如何将磁盘上的页读到Buffer Pool的缓存页里边去"></a>如何将磁盘上的页读到Buffer Pool的缓存页里边去</h4><h4 id="怎么知道数据页有没有被缓存"><a href="#怎么知道数据页有没有被缓存" class="headerlink" title="怎么知道数据页有没有被缓存"></a>怎么知道数据页有没有被缓存</h4><p><strong>数据页哈希缓存</strong></p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509080415925.png" alt="image-20210509080415925" style="zoom:50%;">

<blockquote>
<p>缓存碎片：</p>
<p>Buffer Pool 将内存空间分配至缓存页和描述数据后，有可能会剩余一点内存空间什么都不够存放，这就产生了内存碎片。数据库，通过将缓存页和描述数据进行紧密的排列来减少缓存碎片。</p>
</blockquote>
<h3 id="2-3-flush链表"><a href="#2-3-flush链表" class="headerlink" title="2.3 flush链表"></a>2.3 flush链表</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509083205625.png" alt="image-20210509083205625" style="zoom:50%;">

<h4 id="脏数据页是如何产生的"><a href="#脏数据页是如何产生的" class="headerlink" title="脏数据页是如何产生的"></a>脏数据页是如何产生的</h4><h4 id="哪些缓存页是脏页"><a href="#哪些缓存页是脏页" class="headerlink" title="哪些缓存页是脏页"></a>哪些缓存页是脏页</h4><p>引入flush链表</p>
<h3 id="2-4-基于LRU算法淘汰部分缓存"><a href="#2-4-基于LRU算法淘汰部分缓存" class="headerlink" title="2.4 基于LRU算法淘汰部分缓存"></a>2.4 基于LRU算法淘汰部分缓存</h3><h4 id="Buffer-Pool中的缓存页不够用了怎么办？"><a href="#Buffer-Pool中的缓存页不够用了怎么办？" class="headerlink" title="Buffer Pool中的缓存页不够用了怎么办？"></a>Buffer Pool中的缓存页不够用了怎么办？</h4><h4 id="如果选择要淘汰掉的缓存，淘汰谁？"><a href="#如果选择要淘汰掉的缓存，淘汰谁？" class="headerlink" title="如果选择要淘汰掉的缓存，淘汰谁？"></a>如果选择要淘汰掉的缓存，淘汰谁？</h4><h4 id="缓存命中率概念的引入"><a href="#缓存命中率概念的引入" class="headerlink" title="缓存命中率概念的引入"></a>缓存命中率概念的引入</h4><h4 id="引入LRU链表来判断哪些缓存页是不常用的"><a href="#引入LRU链表来判断哪些缓存页是不常用的" class="headerlink" title="引入LRU链表来判断哪些缓存页是不常用的"></a>引入LRU链表来判断哪些缓存页是不常用的</h4><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h4 id="LRU在实际运行当中，可能导致的一些问题"><a href="#LRU在实际运行当中，可能导致的一些问题" class="headerlink" title="LRU在实际运行当中，可能导致的一些问题"></a>LRU在实际运行当中，可能导致的一些问题</h4><h5 id="导致频繁被访问的缓存页先被淘汰的两种情况"><a href="#导致频繁被访问的缓存页先被淘汰的两种情况" class="headerlink" title="导致频繁被访问的缓存页先被淘汰的两种情况"></a>导致频繁被访问的缓存页先被淘汰的两种情况</h5><ol>
<li>预读</li>
<li>全表扫描</li>
</ol>
<h5 id="什么时候会触发预读机制"><a href="#什么时候会触发预读机制" class="headerlink" title="什么时候会触发预读机制"></a>什么时候会触发预读机制</h5><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>MySQL的预读机制有什么作用？他加载一个数据页到缓存中去的时候为什么把一些相邻的数据页也加载到缓存里去呢？这样做的意义在哪里？这是为了应对怎么样的一个场景？</p>
<h3 id="MySQL对LRU算法的优化"><a href="#MySQL对LRU算法的优化" class="headerlink" title="MySQL对LRU算法的优化"></a>MySQL对LRU算法的优化</h3><h4 id="基于冷热数据的分离的方案对LRU算法进行优化"><a href="#基于冷热数据的分离的方案对LRU算法进行优化" class="headerlink" title="基于冷热数据的分离的方案对LRU算法进行优化"></a>基于冷热数据的分离的方案对LRU算法进行优化</h4><h5 id="基于冷热分离的思想设计LRU链表"><a href="#基于冷热分离的思想设计LRU链表" class="headerlink" title="基于冷热分离的思想设计LRU链表"></a>基于冷热分离的思想设计LRU链表</h5><p>冷数据</p>
<p>热数据</p>
<p>innodb_old_blocks_pct</p>
<h5 id="冷数据区域的缓存页什么时候会被放到热数据区域"><a href="#冷数据区域的缓存页什么时候会被放到热数据区域" class="headerlink" title="冷数据区域的缓存页什么时候会被放到热数据区域"></a>冷数据区域的缓存页什么时候会被放到热数据区域</h5><p>innodb_old_blocks_time</p>
<h5 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h5><h3 id="脏数据被刷回磁盘的方式"><a href="#脏数据被刷回磁盘的方式" class="headerlink" title="脏数据被刷回磁盘的方式"></a>脏数据被刷回磁盘的方式</h3><p><strong>定时把LRU链表尾部的部分刷入磁盘</strong></p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603173519976.png" alt="image-20210603173519976" style="zoom:30%;">



<p><strong>把flush链表中的部分缓存页刷入磁盘</strong></p>
<p>上述的后台线程，会在MySQL不怎么忙的时候，把flush链表中的数据都刷到磁盘中去。</p>
<p><strong>无缓存页时候的处理</strong></p>
<p>把LRU链表的冷数据区的尾部找到一个缓存页，将其刷入磁盘，然后将这个缓存页放到free链表中去</p>
<h2 id="数据页（MySQL存储的最小单位）"><a href="#数据页（MySQL存储的最小单位）" class="headerlink" title="数据页（MySQL存储的最小单位）"></a>数据页（MySQL存储的最小单位）</h2><p>一个数据页16kb，一个数据页被加载到Buffer Pool中就变成了缓存页。</p>
<p>数据页的结构如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603171510262.png" alt="image-20210603171510262" style="zoom:20%;">

<p>空闲区域用来存储一行一行的数据。</p>
<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>我们自己创建的表都有一个表空间的概念，再磁盘上都会对应着<strong>表名.ibd</strong>这样一个磁盘数据文件</p>
<p>数据页：最小单位 16kb</p>
<p>1个数据区（extent）=64个数据页  1mb</p>
<p>256个数据区被划分为一组  256mb</p>
<blockquote>
<p>每一组数据区的第一个数据区的前3个数据页都是存放了一些描述信息</p>
</blockquote>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603152226113.png" alt="image-20210603152226113" style="zoom:50%;">



<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603193740827.png" alt="image-20210603193740827" style="zoom:30%;">



<p>redo log用于保证在一个事务被提交了之后，本次事务所做的操作一定会被反应到磁盘上。因为为了性能，MySQL的增删改查是针对BufferPool而不是磁盘进行操作，因此在事务提交之后有可能数据仍在缓存当中没有被刷新会磁盘，此时如果MySQL服务器突然宕机，缓存中的数据将会丢失。</p>
<p>针对这种情况，MySQL设计了redo log。Redo log用于记录本次事务当中所有对数据库的修改。写Redo log的方式是顺序写磁盘，每次都会追加到磁盘末尾（顺序写在这里不必纠结，就知道他很快就行了），因此写Redo log不会对MySQL性能有什么影响。</p>
<h3 id="Redo-log的结构"><a href="#Redo-log的结构" class="headerlink" title="Redo log的结构"></a>Redo log的结构</h3><p>如果是MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE类型的，其结构如下：</p>
<p>日志类型，表空间ID，数据页号，数据页中的偏移量，具体修改的数据</p>
<p>如果是MLOG_WRITE_STRING，其结构如下：</p>
<p>日志类型（MLOG_WRITE_STRING），表空间ID，数据页号，数据页中的偏移量，修改数据长度，具体修改的数据</p>
<h3 id="Redo-log的写入方式"><a href="#Redo-log的写入方式" class="headerlink" title="Redo log的写入方式"></a>Redo log的写入方式</h3><h4 id="存放Redo-Log的容器——Redo-Log-Block"><a href="#存放Redo-Log的容器——Redo-Log-Block" class="headerlink" title="存放Redo Log的容器——Redo Log Block"></a>存放Redo Log的容器——Redo Log Block</h4><p>MySQL中有另外一个数据结构——redo log block，用来存放多个单行的redo log。一个Redo Log Block是512字节，共分为3个部分：</p>
<ul>
<li><p>12字节的Header块头</p>
<p>​    Header块头又由4部分组成：</p>
<ul>
<li>4字节的block no</li>
<li>2字节的data length</li>
<li>2字节的first record group。每个事务都会有多个Redo Log，形成了一个Redo Log Group，group中的第一个Redo Log的偏移量就用这两个字节进行存储。</li>
<li>4字节的checkpoint on</li>
</ul>
</li>
<li><p>496字节的body块体</p>
</li>
<li><p>4字节的trailer块尾</p>
</li>
</ul>
<p>Redo Log Block的整体结构如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210615204720892.png" alt="image-20210615204720892" style="zoom:40%;">

<p>在写Redo Log的时候，现在内存当中把Redo Log写进一个Redo Log Block的数据结构当中去，当内存中的Redo Log Block的512个字节都写满了，再一次性把这个Redo Log Block写入磁盘。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210615205227672.png" alt="image-20210615205227672" style="zoom:50%;">



<h4 id="内存中的缓冲区-Redo-Log-Buffer"><a href="#内存中的缓冲区-Redo-Log-Buffer" class="headerlink" title="内存中的缓冲区-Redo Log Buffer"></a>内存中的缓冲区-Redo Log Buffer</h4><p>Redo Log Buffer是MySQL启动的时候就跟操作系统申请的一块内存空间。Redo Log Buffer与Buffer Pool类似，也是申请出来一片连续的内存，然后里边划分出了N多个空的Redo Log Block，如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618203402331.png" alt="image-20210618203402331" style="zoom:40%;">

<p>可以通过<strong>innodb_log_buffer_size</strong>来指定Redo Log Buffer的大小，其默认大小为<strong>16MB</strong>。这已经足够大了，毕竟一个Redo Log Block才512 字节，一个 Redo Log一般情况下最大可能也就几十个字节。</p>
<p>Redo Log会被先写入内存中Redo Log Buffer，从Redo Log Buffer中的第一个Redo Log Block开始写起。MySQL会对这块Redo Log Buffer有一定的刷盘策略，这个在下一小节详细记录。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618204147687.png" alt="image-20210618204147687" style="zoom:40%;">

<p>在一个事务中，会有多个增删改的操作，那么就会有多个Redo Log，他们组成了一组Redo Log，也就是<strong>Redo Log Group</strong>，每一组Redo Log都会在一个地方暂存，事务执行完了，再把一组Redo Log写入到Redo Log Buffer中去。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618204513902.png" alt="image-20210618204513902" style="zoom:40%;">



<h4 id="Redo-Log-Buffer中的Redo-Log的刷盘时机"><a href="#Redo-Log-Buffer中的Redo-Log的刷盘时机" class="headerlink" title="Redo Log Buffer中的Redo Log的刷盘时机"></a>Redo Log Buffer中的Redo Log的刷盘时机</h4><ol>
<li>Redo Log Buffer的容量如果已经使用了一半了，也就是超过了8MB，此时就会把他们刷入到磁盘文件中去</li>
<li>一个事务提交的时候，必须把这个事务对应的Redo Log Group所在的Redo Log Block刷入到磁盘文件中去</li>
<li>后台线程定时刷新，每隔1秒就会把Redo Log Buffer中的Redo Log Block刷到磁盘文件中去</li>
<li>MySQL关闭的时候，Redo Log Block都会刷入到磁盘文件中去</li>
</ol>
<p>如果产生了高并发，1s中就产生了超过8MB的Redo Log，此时必然会触发第一个刷盘条件。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618205746496.png" alt="image-20210618205746496" style="zoom:40%;">

<p>平时一个事务一般都是在几十到几百毫秒之间执行完的，事务执行完毕则会触发第二个刷盘条件。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619121729679.png" alt="image-20210619121729679" style="zoom:40%;">



<h4 id="磁盘Redo-Log文件的大小控制"><a href="#磁盘Redo-Log文件的大小控制" class="headerlink" title="磁盘Redo Log文件的大小控制"></a>磁盘Redo Log文件的大小控制</h4><p>Redo Log都会写进一个目录中的文件里，可以通过<code>show_viriables like &#39;datadir&#39;</code>来查看这个目录。默认有两个这样的文件，分别为ib_logfile0和ib_logfile1，写满了一个文件就会写下一个文件，其默认大小是<strong>48MB</strong>。默认情况下，如果两个文件都写满了，会继续写入第一个文件，也就是ib_logfile0，并且会覆盖ib_logfile0中之前写入的Redo Log，所以MySQL在默认情况下，只会保留最近的96MB的Redo Log。</p>
<p>MySQL也提供了几个参数来修改默认的设置：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_log_file_size</td>
<td>指定每个Redo Log文件大小</td>
</tr>
<tr>
<td>innodb_log_files_in_group</td>
<td>指定Redo Log文件的数量</td>
</tr>
<tr>
<td>innodb_log_group_home_dir</td>
<td>指定Redo Log文件的存放目录</td>
</tr>
</tbody></table>
<h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>Undo Log主要用在事务的回滚上。当一个事务在执行完之前想要回滚，Undo Log就起到了他的作用，如下图：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619171015437.png" alt="image-20210619171015437" style="zoom:40%;">

<p>从最抽象的顶层来看，Undo Log记录的内容很简单，分增删改三种：</p>
<ul>
<li>insert：会记录一个主键和一个对应的delete操作</li>
<li>delete：会把删除的那条数据记录下来</li>
<li>update：会把更新前的那个值记录下来</li>
</ul>
<h3 id="剖析Insert语句的Undo-Log"><a href="#剖析Insert语句的Undo-Log" class="headerlink" title="剖析Insert语句的Undo Log"></a>剖析Insert语句的Undo Log</h3><p>一条Inser语句的Undo Log包括以下内容：</p>
<ul>
<li><p>这条日志的开始位置</p>
</li>
<li><p>主键的各列长度和值</p>
</li>
<li><p>表Id</p>
</li>
<li><p>Undo Log 日志编号</p>
<p>每个Undo Log都有自己的编号，每个事物里的Undo Log日志的编号都是从0开始的，依次递增。</p>
</li>
<li><p>Undo Log日志类型</p>
<p>Inser 语句的Undo Log的日志类型是：<strong>TRX_UNDO_INSERT_REC</strong></p>
</li>
<li><p>这条日志的结束位置</p>
</li>
</ul>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619172815970.png" alt="image-20210619172815970"></p>
<h2 id="多事务并发"><a href="#多事务并发" class="headerlink" title="多事务并发"></a>多事务并发</h2><p>MySQL的多事务并发示意图如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619174648835.png" alt="image-20210619174648835" style="zoom:40%;">

<p>在多事务并发的情况下会产生很多的问题，比如：</p>
<ul>
<li>对Buffer Pool中的同一行数据进行更新的时候，这个冲突怎么处理？</li>
<li>可能有事务事务在对一行数据做更新，但是另外一个事务在查询折行数据，这个冲突又怎么处理？</li>
</ul>
<p>说白了就是，<strong>在多事务并发的时候，MySQL应该如何合理的分配资源</strong>。</p>
<p>接下来，在多事务并发这一节中主要围绕的就是对于资源冲突的情况，MySQL内部的一些处理机制是怎样的，包括：</p>
<ul>
<li>事务的隔离级别</li>
<li>MVCC多版本隔离</li>
<li>锁机制</li>
</ul>
<h3 id="多事务并发会导致的4种常见问题"><a href="#多事务并发会导致的4种常见问题" class="headerlink" title="多事务并发会导致的4种常见问题"></a>多事务并发会导致的4种常见问题</h3><h4 id="1-脏写"><a href="#1-脏写" class="headerlink" title="1. 脏写"></a>1. 脏写</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620134633714.png" alt="image-20210620134633714" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620134706929.png" alt="image-20210620134706929" style="zoom:50%;">

<p>事务B明明自己已经把一行记录更新了，但是值却没了，这就是脏写。</p>
<blockquote>
<p>脏写其实就是，对于任意一个事务，写入的某行记录的值随时可能被其他事务更改。</p>
</blockquote>
<h4 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135254424.png" alt="image-20210620135254424" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135311181.png" alt="image-20210620135311181" style="zoom:50%;">

<p>事务B第一次查出来的是A值，然后拿着A这个值去做各种业务处理，但是第二次再去查询的时候该值变成了NULL。</p>
<blockquote>
<p>脏读其实就是，对于任意事务，当前读出来的值在以后可能被其他事务所更改。</p>
</blockquote>
<h4 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135845983.png" alt="image-20210620135845983" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135901501.png" alt="image-20210620135901501" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135930844.png" alt="image-20210620135930844" style="zoom:50%;">

<p>事务A每次读出来的值都是不一样的，这就叫做不可重复读。</p>
<p>不可重复度这个问题不一定会对业务系统产生影响，这取决于业务系统的要求。如果每次读出来的值都是不一样的，但是对于业务系统来说这没什么问题，那么不可重复读就是一种正常现象。但是如果希望事务开始之后，对于同一行记录，读到的值自始至终都是一样的，那么不可重复读就会对业务系统产生影响。</p>
<p><strong>因此，不可重复读是否会产生影响，取决于业务系统的要求。</strong></p>
<h4 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620140653915.png" alt="image-20210620140653915" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620140713230.png" alt="image-20210620140713230" style="zoom:50%;">

<p>事务A用<strong>一模一样的SQL语句</strong>进行了两次查询，查询出来的结果是不一样的，这就是幻读。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</p>
<h4 id="不可重复读VS幻读"><a href="#不可重复读VS幻读" class="headerlink" title="不可重复读VS幻读"></a>不可重复读VS幻读</h4><p>在学习的过程当中我对不可重复读和幻读没法完全的将这两个现象拆分开，现在就把这两种现象放在一块做一下分析。</p>
<p>从表征上来看，不可重复读和幻读的结果都是两次读取产生的结果不一样，但是如果进入到细节来看，可以发现他们还是有区别的。不可重复读，两次读取的结果不一样的地方在于两次读取的<strong>值</strong>不一样，重点在于读取的值，也就是其他事物的update操作和delete操作会对其产生影响，而insert却没什么影响；幻读，两次读取的结果不一样的地方在于两次读取的结果数量不一样，也就是其他事务的insert操作和delete操作对其会产生影响，而update却没什么影响。</p>
<blockquote>
<p>幻读和不可重复读的理解，暂时先止于此，可能理解上有误，但不耽误接下来的学习。</p>
</blockquote>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li>读未提交（read uncommitted）（此事务还没提交，别人就能读到在该事务中更新后的结果），一个事务还没提交时，它做的变更就能被别的事务看到，该隔离级别可以避免脏写。</li>
<li><strong>读提交（read committed，RC）</strong>（此事务还没提交，别人无法读到在该事务中更新后的结果），一个事务提交之后，它做的变更才会被其他事务看到，改革立级别可以避免脏写和脏读。</li>
<li><strong>可重复读（repeatable read，RR）</strong>（别人做的任何数据更改，不影响本事务，本事务始终读的都是事务开始时候的快照），一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的，该隔离级别可避免不可重复读，但不能避免幻读。</li>
<li>串行化（serializable），顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>在MySQL当中，默认的隔离级别是RR级别，也就是说使用MySQL默认隔离级别就能避免幻读，这依靠了他的MVCC机制——多版本并发控制隔离机制，之后会详细记录这个MVCC，这是一个重点内容。</p>
<h3 id="MVCC前奏，Undo-Log版本链"><a href="#MVCC前奏，Undo-Log版本链" class="headerlink" title="MVCC前奏，Undo Log版本链"></a>MVCC前奏，Undo Log版本链</h3><p>简单来说，数据库中的没条记录都存在两个隐藏字段：</p>
<ul>
<li>trx_id</li>
<li>roll_pointer</li>
</ul>
<p>trx_id就是最近更新这条数据的事务Id，roll_pointer指向了最近的一个事务对这条记录进行改动的Undo Log。举例来说：</p>
<p>事务A，id为50，在数据库中插入了一条数据，那么此时这条数据的trx_id为50，roll_pointer指向了一个空的Undo Log。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621200649616.png" alt="image-20210621200649616" style="zoom:50%;">

<p>接着，事务B，id为58，更新了这条记录，那么此时这条数据的trx_id为58，roll_pointer指向了事务A生成的Undo Log，图中的Undo Log只画出来了Undo Log的一部分内容——也就是事务B更新这条记录之前的值，包括了这条记录所有的字段的值，其他部分没有画出来因为并不影响理解。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621201835298.png" alt="image-20210621201835298" style="zoom:50%;">

<p>接着，事务C，跟事务B一样，不再赘述。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621204053849.png" alt="image-20210621204053849" style="zoom:50%;">

<p>以上，在事务串行的场景下，记录了MySQL的Undo Log版本链，Undo Log版本链是MVCC的基础。</p>
<h3 id="基于Undo-Log版本链实现的ReadView机制"><a href="#基于Undo-Log版本链实现的ReadView机制" class="headerlink" title="基于Undo Log版本链实现的ReadView机制"></a>基于Undo Log版本链实现的ReadView机制</h3><p>ReadView，简单来说就是你执行一个事务的时候，就会生成一个<strong>ReadView</strong>，里边有比较关键的4个东西：</p>
<ul>
<li><strong>m_ids</strong>，数据库中还没有提交的事务的id——可以认为这是事务是与本事务并发执行的事务</li>
<li><strong>min_trx_id</strong>，m_ids里的最小值</li>
<li><strong>max_trx_id</strong>，数据库中下一个要生成的事务的id，也就是m_ids里的最大值</li>
<li><strong>creator_id</strong>，当前这个事务的id</li>
</ul>
<p>下边通过举例，来描述ReadView是如何使用的。</p>
<ol>
<li>数据库中有一条最原始的记录是这样的：</li>
</ol>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205330262.png" alt="image-20210621205330262" style="zoom:30%;">

<ol start="2">
<li>接着来了两个事务，事务A、事务B。事务A要读取这行记录，事务B要更新这条记录，此时事务A的ReadView的情况为：</li>
</ol>
<ul>
<li>m_ids = [45,59]</li>
<li>min_trx_id = 45</li>
<li>max_tr_id = 59</li>
<li>creator_id = 45</li>
</ul>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205457917.png" alt="image-20210621205457917" style="zoom:50%;">

<ol start="3">
<li>事务A在查询该记录的时候，会判断该记录中的trx_id是否小于ReadView中的min_trx_id，发现记录的trx_id = 32,ReadView中的min_trx_id=45，这说明在ReadView生成的时候，id为32的事务就已经提交了，因此是事务A能够正常查询到这条记录的的原始值：</li>
</ol>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205646584.png" alt="image-20210621205646584" style="zoom:50%;">

<ol start="4">
<li>接着，事务B开始更新这条数据，把数据的值更新成了B，trx_id更新成了自的id——也就是59，同时roll_pointer指向了一个Undo Log，该Undo Log记录了更新前的记录。最后，事务B提交。</li>
</ol>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627123722779.png" alt="image-20210627123722779"></p>
<ol start="5">
<li>然后，事务A又来查询，此时事务A发现了几个事情：</li>
</ol>
<ul>
<li>这条数据的trx_id = 59，比ReadView中的min_trx_id大，这说明：<strong>自己的事务开启之后，这条记录被事务Id为59的事务更新过并且该事务已经提交</strong></li>
<li>这条数据的trx_id = 59，比ReadView中的max_trx_id小，这说明：<strong>更新这条记录的这个事务基本上是跟自己同时开启的</strong></li>
<li>这条数据的trx_id = 59，m_ids = [45,59]，trx_id存在与m_ids中，<strong>直接证明该事务是与本事务同期并发执行的事务</strong></li>
</ul>
<p>此时，A得出了结论，<strong>该记录不能读</strong>。于是，A顺着roll_pointer找到了最近的那个Undo Log，trx_id是32，发现：</p>
<ul>
<li>该Undo Log的trx_id是32，比ReadView中的minx_trx_id小，这说明：<strong>这个Undo Log的版本必然是在事务A开启之前就执行切提交的。</strong></li>
</ul>
<p>此时，A会从这个Undo Log中读取到原始值。</p>
<p>这就是Undo Log版本链的作用，<strong>他可以保存数据的一个版本链条，让你可以读到数据之前的快照中的值。</strong></p>
<blockquote>
<p>这里遗留了一个问题：Undo Log版本链中的Undo Log不可能无限增加吧，那么他是什么时候被删除的呢？</p>
</blockquote>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627151926578.png" alt="image-20210627151926578"></p>
<ol start="6">
<li><p>接着，A自己更新了这条记录。</p>
<ul>
<li>将记录的改成了值A；trx_id修改为45；同时保存本次更新前的记录的快照；</li>
</ul>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152258485.png" alt="image-20210627152258485"></p>
</li>
<li><p>然后，A自己再来查询这条记录，发现：</p>
<ul>
<li>这调数据的trx_id是45，与ReadView中的creator_id相同，这说明：<strong>这条数据就是自己改的</strong></li>
</ul>
<p>因此，A得出结论，这条记录是可以读的。</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152519540.png" alt="image-20210627152519540"></p>
</li>
<li><p>接着，事务A还没有提交，又来个事务C，这个事务的id是78，将这条记录的值更新成了值C并提交：</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152734979.png" alt="image-20210627152734979"></p>
</li>
<li><p>事务A此时再来查询，发现：</p>
<ul>
<li>当前数据的trx_id=78，比ReadView中的max_trx_id大，这说明：<strong>在事务A开启之后，事务C更新了数据</strong></li>
</ul>
<p>因此，事务A得出结论：该数据记录不可读，于是顺着roll_pointer开始寻找可读数据，就找到了值为A的那条记录，于是就读到了值A。</p>
</li>
</ol>
<blockquote>
<p>这里有一点自己的思考：</p>
<p>一个事务的开启应该是包含了几个固定的过程，其中就包含m_ids，min_trx_id，max_trx_id，creator_id这几个值捕获这个过程，这个过程会捕获所有当前事务开启时的正在活跃中的事务Id。当这几个固定的过程都完成后，一个事务才算是开启。因此，当发现一条记录的trx_id比自己m_ids中的最大id还大的时候，就完全能够说明这个事务是在本事务开启之后开启的。</p>
</blockquote>
<p><strong>RC级别是如何基于ReadView机制实现的</strong></p>
<p>RC隔离级别，是本事务可以读其他事务已更新并且已提交了的值。该隔离级别的实现原理就是：</p>
<p><strong>在一个事务中，每次读取操作，都会生成一个ReadView。</strong></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155440120.png" alt="image-20210627155440120"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155517384.png" alt="image-20210627155517384"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155558291.png" alt="image-20210627155558291"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155857805.png" alt="image-20210627155857805"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627160137458.png" alt="image-20210627160137458"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627160205957.png" alt="image-20210627160205957"></p>
<h3 id="脏写是如何被避免的"><a href="#脏写是如何被避免的" class="headerlink" title="脏写是如何被避免的"></a>脏写是如何被避免的</h3><p>MVCC是用来解决多事务并发的时候，读操作与其他事务的写操作之间的协调问题。而数据库的锁机制，是用来解决多个事务同时更新同一条记录时候，产生的脏写的问题。</p>
<p>老样子，继续举例说明。</p>
<ol>
<li><p>当一个事务A想要更新某条记录的时候，他会先看看这行数据此时有没有被其他事务加锁。如果没人加锁，那说明这条记录本事务是可以更新的，于是该事务会新建一个锁，锁中包含了：</p>
<ul>
<li><p>事务的trx_id = 50</p>
</li>
<li><p>等待状态 = false</p>
</li>
</ul>
<p>然后，把该锁跟要更新的那条数据关联起来：</p>
</li>
</ol>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627164105180.png" alt="image-20210627164105180"></p>
<ol start="2">
<li>此时，事务B也想更新这条记录，发现这条记录已经被加锁了，于是事务B也在内存中产生了一个锁数据结构，所数据结构中的各项状态为：</li>
</ol>
<ul>
<li>事务的trx_id = 60</li>
<li>等待状态 = true</li>
</ul>
<p>然后等着该条记录的锁被释放就行了。</p>
<p>注意，事务B的等待状态是true。</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627164832979.png" alt="image-20210627164832979"></p>
<ol start="3">
<li>接着，事务A更新完了数据，会释放掉锁，然后去找此时还有没有其他人也对这行记录加了锁，发现B也对这行记录加了锁，于是将B的等待状态改为false，接着唤醒B事务继续执行，此时事务B就获取到锁了。</li>
</ol>
<h3 id="行级锁：共享锁和独占锁"><a href="#行级锁：共享锁和独占锁" class="headerlink" title="行级锁：共享锁和独占锁"></a>行级锁：共享锁和独占锁</h3><p>上一小节讲到的更新操作加的锁实际上是一种<strong>独占锁</strong>，而独占锁对于默认的读操作来说是透明的，因为读操作走的是MVCC机制，满足了MVCC机制就必然能够去读这行数据，完全不用考虑是否有其他事务正在更新这条数据。读操作默认情况下走MVCC机制，完全不考虑锁的情况，因此读操作默认情况下也不会对要读的记录加锁。</p>
<p>但是，<strong>MySQL也对读操作的时候加读锁提供了支持</strong>。</p>
<p>首先是读操作时候的共享锁。可以在一个查询语句的最后加上<code>lock in share mode</code>，意思就是在查询的时候对这行记录加上共享锁。但是共享锁跟独占锁是互斥的，若此时这条记录已经加上了独占锁，该查询就只能处于等待状态了。共享锁和共享锁之间是不互斥的，也就是说同一条记录，两个事务都来加共享锁是没问题的，两个事务都不会等待，直接就可以读取这条记录的值。</p>
<blockquote>
<p>看来，读操作的时候加的共享锁，就是为了排斥更新操作的，我读的时候别人不能更新。</p>
</blockquote>
<p>然后是读操作时候的独占锁。可以在一个查询语句的最后加上<code>for update</code>，意思就是在查询的时候对这行记录加上独占锁。读操作时候的独占锁代表的是，这条数据我查出来之后还要更新，其他人不要更新这条数据了。</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>独占锁</th>
<th>共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>独占锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>共享锁</td>
<td>互斥</td>
<td>不互斥</td>
</tr>
</tbody></table>
<p>读操作的时候手动的加锁这种情况是很少见的，一般不会在数据库层面做复杂的手动加锁的操作，因为在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁分为两种：</p>
<ul>
<li>表锁</li>
<li>表级意向锁</li>
</ul>
<p>首先说说表锁，表锁的添加语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--表级共享锁</span><br><span class="line">LOCK TABLE XXX READ</span><br><span class="line">--表级独占锁</span><br><span class="line">LOCK TABLE XXX WRITE</span><br></pre></td></tr></table></figure>

<p>表锁不常用，很少会手动的去加表锁。</p>
<p>然后说说表级意向锁，意向锁都是<strong>自动加上去</strong>的。有两种情况会加表级意向锁：</p>
<ul>
<li>有事务在做<strong>增删改</strong>操作的时候，除了会在行级加独占锁，同时也会在表级加意向独占锁</li>
<li>有事务在做查询操作的时候，会在表中加一个意向共享锁</li>
</ul>
<p>这两种锁都是在执行增删改查的时候自动在表级加的锁，他们之间是不存在互斥关系的，彼此互相透明，谁也看不见谁。然而，他们和手动加的表级所是存在互斥关系的，互斥关系如图：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>手动加的表级共享锁</th>
<th>手动加的表级独占锁</th>
<th>意向独占锁</th>
<th>意向共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>手动加的表级共享锁</td>
<td>不互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>不互斥</td>
</tr>
<tr>
<td>手动加的表级独占锁</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>意向独占锁</td>
<td>互斥</td>
<td>互斥</td>
<td>不互斥</td>
<td>不互斥</td>
</tr>
<tr>
<td>意向共享锁</td>
<td>不互斥</td>
<td>互斥</td>
<td>不互斥</td>
<td>不互斥</td>
</tr>
</tbody></table>
<h3 id="案例实战：线上数据库的随机性能抖动优化"><a href="#案例实战：线上数据库的随机性能抖动优化" class="headerlink" title="案例实战：线上数据库的随机性能抖动优化"></a>案例实战：线上数据库的随机性能抖动优化</h3><p>先说引起抖动的可能的原因：</p>
<ul>
<li>一个查询语句，需要查询大批量的数据，导致需要将Buffer Pool中的脏页大量刷入磁盘，才能空余出空间来执行这条SQL语句。</li>
<li>所有Redo Log文件都写满了，需要开始覆盖第一个Redo Log文件中的Redo Log，此时会检查如果第一个Redo Log文件里边的一些redo log对应之前更新过的Buffer Pool中的缓存页，迄今为止都没刷入磁盘，此时必须要把那些马上那些缓存页刷入磁盘。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>尽量减少缓存页flush到磁盘的频率</p>
</li>
<li><p>尽量提升缓存页flush到磁盘的速度</p>
</li>
</ul>
<p>减少频率很困难，着重放在第二个解决方案上。</p>
<p>要提升缓存页flush到磁盘的速度，通常的建议就是：<strong>对于数据库部署的机型，采用SSD固态硬盘，而不是机械硬盘，SDD固态硬盘最强大的地方，就是他的随机IO性能非常高。</strong></p>
<p>flush缓存页到磁盘，是典型的随机IO，需要在磁盘上找到各个缓存页所在的随机位置，把数据写入到磁盘里去。所以如果采用的是SSD固态硬盘，那么flush缓存页到磁盘的性能首先就会有很大的提高。</p>
<p>光用SSD还不够，还必须要设置MySQL一个非常关键的参数：<code>innodb_io_capacity</code>，这个参数就是告诉数据库采用多大的IO速率吧缓存页flush到磁盘中去。举例来说：如果SSD能承载的每秒随机IO数是600，但是这个参数设置的是300，那flush缓存页到磁盘的时候，每秒最多就稚嫩执行300次随机IO，根本没有发挥出SSD的性能。还有另外一个重要的参数：<code>innodb_flush_neighbors</code>，这个参数用于说明，在flush缓存页到磁盘的时候可能会把缓存页附近的其他缓存页也刷到磁盘，但是这样有时候会导致flush的缓存页太多了。实际上如果用的是SSD，并没有炳耀设置这个参数，设置成0就好了。</p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="headerlink" title="磁盘数据页的存储结构"></a>磁盘数据页的存储结构</h3><p>磁盘上大量的数据页是按顺序一页一页存放的，两两相邻的数据页之间会采用双向链表的方式互相引用，看起来如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714140446086.png" alt="image-20210714140446086" style="zoom:50%;">

<p>一个数据页在磁盘上存储的样子可以<strong>大致</strong>是这样（当然了，这是解码之后又人为臆想的，并不完全是真实如此的）：</p>
<blockquote>
<p>DataPage: xx=xx, xx=xx, linked_list_pre_pointer=15367, linked_list_next_pointer=34126 || DataPage: xx=xx, xx=xx, linked_list_pre_pointer=23789, linked_list_next_pointer=46589 || DataPage: xx=xx, xx=xx, linked_list_pre_pointer=33198, linked_list_next_pointer=55681</p>
</blockquote>
<p>可以看见每个数据页都有两个指针，分别指向上一个数据页在磁盘文件中的起始物理位置和下一个数据页在磁盘文件中的起始物理地址。</p>
<p>然后一个数据页内部会存储一行行的数据，数据页里边的每一行数据都会按照主键的大小进行排序存储，通知每一行数据都有指向下一行数据位置的指针，组成了单项链表。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714151950726.png" alt="image-20210714151950726" style="zoom:50%;">



<p>每个数据页都会有一个页目录，页目录中存放的是主键和槽位的映射关系。数据行是被分散的存储到不同的槽位中去的，每个槽位中存放了多条数据，如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714152632491.png" alt="image-20210714152632491" style="zoom:50%;">



<h3 id="无索引的搜索数据搜索"><a href="#无索引的搜索数据搜索" class="headerlink" title="无索引的搜索数据搜索"></a>无索引的搜索数据搜索</h3><p>假设，现在要根据主键查找一条数据，而且此时数据库表中也没有几条数据，表中<strong>一共就一个数据页</strong>，那么就会先到页目录中根据主键进行二分查找迅速定位到数据在哪个槽位中，然后再到槽位中遍历每一行数据，很快就能找到该主键对应的数据了。要是非主键的查找，尴尬，只能进到数据页中，根据单向链表遍历查找了。</p>
<p>如果是多个数据页，无论是否根据主键去查，都无法取巧。只能根据页与页之间的链表关系，以及页中的数据行之间的链表关系，如果是主键查询可以用二分查找，非主键就只能遍历了。这个过程，就是臭名昭著的<strong>全表扫描</strong>。就是根据双向链表，一次吧磁盘上的数据页加载到缓存中去，然后在一个缓存页内部来查找那条数据。</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>在表中不停的插入数据的时候，会有一个页分裂的过程。数据在不停地插入的过程中，一个数据页是肯定是无法容纳所有的数据的，此时就必须搞出来一个新的数据页来容纳新的数据。但是，MySQL有一个规则，<strong>新数据页中的主键的值必须比旧数据页中的主键值都小</strong>。如果表的主键是自增长的，那这个天然就能满足MySQL的规则；如果不是自增长的就涉及到了<strong>页分裂</strong>。这个所谓的页分裂其实就是在新数据页出现的时候，让数据的主键维持上述规则，具体如何做这里不细究，只需要知道无论主键是否是自增长的，。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714161818252.png" alt="image-20210714161818252" style="zoom:50%;">



<h3 id="主键目录"><a href="#主键目录" class="headerlink" title="主键目录"></a>主键目录</h3><p>前提：有多个数据页，然后根据主键进行查询。</p>
<p>问题：主键在哪个数据页中？不知道主键在哪个数据页中，那还是要走全局扫描啊。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716073321488.png" alt="image-20210716073321488" style="zoom:50%;">

<p>因此，出现了主键目录这个概念：<strong>针对主键设计的目录</strong>。目录中存放的是每个数据页的页号和每个数据页中的最小主键的值的映射关系，如图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716073616519.png" alt="image-20210716073616519" style="zoom:50%;">

<p>此时，问题得以完美解决，可以用主键索引到主键目录中去进行二分查找，最终就可以得到想要的数据所在的页号了，然后到所在的页中进行二分查找即可。</p>
<h3 id="索引的存储结构——B-Tree"><a href="#索引的存储结构——B-Tree" class="headerlink" title="索引的存储结构——B+Tree"></a>索引的存储结构——B+Tree</h3><p>当表中数据非常多，几百万、几千万甚至上亿，磁盘上会有大量的数据页，因此主键目录中的数据页号和数据页中的最小主键的映射关系也会非常的多，此时基于主键进行查找的话，效率会明显降低，那么要如何解决这个问题呢？</p>
<p>实际上，索引也是存放在页中的，索引所在的页叫做<strong>索引页</strong>，数据页特别多的时候也会产生很多的索引页，如图所示。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716075116765.png" alt="image-20210716075116765" style="zoom:50%;">

<p>那么此时问题又来了，根据主键查询的时候，<strong>如何能够知道主键所在的索引页呢</strong>？解决方案其实已经有了，刚刚的上一小节已经说过，数据页比较多的时候，我们整出来了一个数据页的索引页来帮助判定数据所在的数据页，那么同理，索引页比较多的时候，我们可以整出来一个索引页的索引页，来帮助判定索引所在的索引页。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716075654553.png" alt="image-20210716075654553" style="zoom:50%;">

<p>问题又来了，如果索引页的索引页又比较多了怎么办？老办法，再搞出一个索引页的索引页的索引页，一个思想进行到底，如图所示。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716080442908.png" alt="image-20210716080442908" style="zoom:50%;">

<p>此时，索引的多层级关系已经能够很明显的看出来了，这个层级分明的结构就是我们经常所提及的B+Tree。</p>
<p>当主键索引建立起来之后，其实这个主键索引的结构就是一颗B+Tree，根据主键查询数据的时候，直接从B+Tree的顶层开始二分查找，一层层向下定位，最终定位到了一个数据页中，然后在数据页内部的页目录中进行二分查找就可以很快的找到主键所对应的那条数据。</p>
<p>总结：</p>
<ul>
<li>索引数据存储在于数据页一样的索引页中。</li>
<li>一个索引就是很多索引页组成的一颗B+Tree。</li>
</ul>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>如果一颗大的B+Tree索引数据结构里，叶子节点就是数据页自己本身，那么此时既可以称这颗B+Tree为聚簇索引。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717115058109.png" alt="image-20210717115058109" style="zoom:50%;">

<p>聚簇索引里就包含了数据，数据存放于聚簇索引的叶子节点。聚簇索引是按照主键来组织的。InnoDB会基于主键默认给我们建立聚簇索引。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>假设要根据主键之外的字段——name字段来建立索引，那么InnoDB会再重新建立一颗B+Tree，但是<strong>数据页里仅仅放主键字段和name字段</strong>，其他的跟聚簇索引都一样。之所以存放主键，是为了如果查询语句中还需要查询除了name之外其他字段的时候，可以现在name索引的这颗B+Tree上先查询，查询到数据之后，再用主键再到聚簇索引中进行<strong>回表</strong>查询其他需要的字段。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717121109605.png" alt="image-20210717121109605" style="zoom:50%;">

<p>也可以把多个字段联合起来建立<strong>联合索引</strong>，比如 name + age。此时联合索引的运行原理也是一样的，只不过是建立一颗独立的B+Tree，然后叶子节点中存放的是id + name + age，默认按照name排序，name一样就按照age排序。</p>
<h3 id="联合索引的使用规则"><a href="#联合索引的使用规则" class="headerlink" title="联合索引的使用规则"></a>联合索引的使用规则</h3><p>假设有一张表，用来存储学生成绩，主键id是自增的，默认会根据他建立聚簇索引，这个不用多说。然后，包含了：</p>
<ul>
<li>学生班级</li>
<li>学生姓名</li>
<li>科目名称</li>
<li>成绩</li>
</ul>
<p>四个字段。</p>
<p>此时，我们给可以针对学生班级、学生姓名、科目名称建立一个联合索引。索引组成的B+Tree如下图：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717124543448.png" alt="image-20210717124543448" style="zoom:50%;">

<p>接下来，根据这个场景，来简单介绍下联合索引的几个使用规则，也就说，如果满足了这些规则，那么我们的SQL就是能够使用联合索引进行查询的，反之则不能。</p>
<h4 id="等值匹配规则"><a href="#等值匹配规则" class="headerlink" title="等值匹配规则"></a>等值匹配规则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name<span class="operator">=</span><span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> student_name<span class="operator">=</span><span class="string">&#x27;张小强&#x27;</span> <span class="keyword">and</span> subject_name<span class="operator">=</span><span class="string">&#x27;数学&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，where条件里的几个字段有几个值得注意的点：</p>
<ul>
<li>都是基于等值来查询，都是用的等号</li>
<li>字段的名称和顺序跟联合索引一模一样</li>
</ul>
<p>这个就是<strong>等值匹配规则</strong>。即使字段顺序和联合索引不一样，也没关系，MySQL会自动优化为按联合索引的字段顺序去找。</p>
<h4 id="最左侧列匹配原则"><a href="#最左侧列匹配原则" class="headerlink" title="最左侧列匹配原则"></a>最左侧列匹配原则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="operator">=</span> &quot;&quot; <span class="keyword">and</span> studnt_name <span class="operator">=</span> &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这个时候，只要根据联合索引中最左侧的部分字段进行查询就可以，这个SQL是可以用的上联合索引的。</p>
<h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;1%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个sql也是可以用上索引的。</p>
<p>但是如果把SQL写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;%班&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就用不上索引了。</p>
<h4 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h4><p>如果where条件中如果有范围查询，那只有对联合索引里最左侧的列进行范围查询才能用到索引。例如有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="operator">&gt;</span> <span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> class_name <span class="operator">&lt;</span> <span class="string">&#x27;5班&#x27;</span> <span class="keyword">and</span> student_name <span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这条语句中，只有class_name是可以基于索引来做查询的，student_name的范围查询是没法用到索引的。</p>
<h4 id="等值匹配-范围匹配"><a href="#等值匹配-范围匹配" class="headerlink" title="等值匹配 + 范围匹配"></a>等值匹配 + 范围匹配</h4><p>假设有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score whre class_name <span class="operator">=</span> <span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> student_name<span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> subject_name <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据等值匹配规则，class_name可以用得上索引，先根据class_name = ‘1班’筛选出来一波数据，筛选出来的数据中的student_name必然都是排好序的，所以student_name&gt; ‘’也是可以用得上索引的，但是接下来的subject_name &lt; ‘’是不能用索引的。</p>
<h4 id="order-by的索引使用规则"><a href="#order-by的索引使用规则" class="headerlink" title="order by的索引使用规则"></a>order by的索引使用规则</h4><p>最好根据联合索引的顺序写order by语句，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">order</span> <span class="keyword">by</span> class_name , student_name , subject_name</span><br></pre></td></tr></table></figure>



<h4 id="group-by的索引使用规则"><a href="#group-by的索引使用规则" class="headerlink" title="group by的索引使用规则"></a>group by的索引使用规则</h4><p>最好根据联合索引的顺序写order by语句，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">group</span> <span class="keyword">by</span> class_name , student_name , subject_name</span><br></pre></td></tr></table></figure>



<h3 id="覆盖索引是什么"><a href="#覆盖索引是什么" class="headerlink" title="覆盖索引是什么"></a>覆盖索引是什么</h3><p>覆盖索引其实不是一种索引，他就是一种基于索引查询的方式罢了。</p>
<p>他的意思就是，我仅仅需要查询联合索引里的几个字段的值，那么其实就只要扫描联合索引的索引树就可以了，不需要回表去聚簇索引里找其他字段了。</p>
<p>因此，在写SQL的时候：</p>
<ul>
<li>尽量的不要写select * ，避免回表，最好是能走覆盖索引。</li>
<li>就算是真的要回表，也尽可能用limit、where这样的语句限定下回表的次数。</li>
</ul>
<h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><h4 id="索引设计的步骤"><a href="#索引设计的步骤" class="headerlink" title="索引设计的步骤"></a>索引设计的步骤</h4><ol>
<li>表结构设计完毕后，不要着急设计索引，因为此时根本不知道该怎么查询表</li>
<li>当系统差不多开发完毕了，功能都跑通了，就能完全知道如何对一张表发起一些什么样的SQL语句</li>
<li>针对SQL语句里边的where条件、order by语句以及group by条件去设计索引</li>
<li>可以设计一个或者两三个联合索引，每一个联合索引都尽量去包含where、order by、group by里的字段</li>
<li>审查每个SQL语句，是否都满足最左侧列原则</li>
</ol>
<h4 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h4><ul>
<li>（比较重要）尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能<strong>发挥出B+Tree快速二分查找的优势</strong></li>
<li>尽量针对那些字段的类型比较小的列来设计索引，比如tinyint之类的，这样会让索引树占用的磁盘空间更小，查询效率更高</li>
<li>如果索引字段比较大，比如varchar(255)，可以考虑一下，仅仅针对这个varchar(255)字段的前20个字符建立索引。当然，ordre by 跟 group by是用不上这样的索引的。where可以用上，但是在查询语句中的查询字段中要查询这个索引字段的时候，就需要回表了</li>
<li>（比较重要）如果给索引字段搞了个函数或者搞了个计算，那么此时是无法使用索引的</li>
<li>索引别设计太多，因为插入的数据的值可能不是按照顺序来的，很可能导致索引树里边的某个页会自动分裂，这个分裂的过程很耗费时间，<strong>一般两三个联合索引就应该覆盖掉这个表的全部查询了</strong></li>
<li>建议主键要是自增的，别用UUID之类的，因为主键自增的话，起码聚簇索引不会频繁的分裂，只会自然的新增一个页</li>
</ul>
<h4 id="实战场景下的索引设计技巧"><a href="#实战场景下的索引设计技巧" class="headerlink" title="实战场景下的索引设计技巧"></a>实战场景下的索引设计技巧</h4><ul>
<li><p>在有些SQL中，where和order by实际上大部分情况下是没法都用到索引的，鱼和熊掌不可兼得。一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据接着再进行排序，最后针对排序后的数据拿出来一页数据</p>
</li>
<li><p>基数较低的字段<strong>但是频繁查询</strong>的字段也可以放到联合索引的最左侧去</p>
</li>
<li><p>经常用于范围查询的字段，一定要放在联合索引的最后</p>
</li>
<li><p>针对一些<strong>频繁使用的包含枚举值范围的一些字段，也完全可以加入到联合索引里去</strong>，可以设计成（province, city, sex, hobby, character, age）这样的一个联合索引，此时假设出现了这样一个查询，按照省份、城市、性格和年龄进行搜索，此时SQL怎么写？就是写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> province<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx <span class="keyword">and</span> sex <span class="keyword">in</span>(xx, xx) <span class="keyword">and</span> hobby <span class="keyword">in</span> (xx, xx, xx, xx) <span class="keyword">and</span> <span class="type">character</span><span class="operator">=</span>xx <span class="keyword">and</span> age<span class="operator">&gt;=</span>xx <span class="keyword">and</span> age<span class="operator">&lt;=</span>xx</span><br></pre></td></tr></table></figure>

<p>也就是说，即使你不需要按性别和爱好进行筛选，但是在SQL里你可以对这两个字段用in语句，把他们所有的枚举值都放进去</p>
</li>
<li><p>可以针对那些基数很低的字段，在家还是那个排序字段单独额外设计一个<strong>辅助索引</strong>，专门用于解决<strong>where条件中都是基数低的字段，然后还需要排序后分页的问题</strong></p>
</li>
<li><p>尽量利用一两个复杂的多字段联合索引，抗下80%以上的查询，然后用一两个辅助索引抗下神域的20%的非典型查询，保证99%以上的查询都能充分利用索引，这样就能保证系统整体的查询速度和性能</p>
</li>
</ul>
<h2 id="SQL语句执行计划"><a href="#SQL语句执行计划" class="headerlink" title="SQL语句执行计划"></a>SQL语句执行计划</h2><h4 id="查询级别"><a href="#查询级别" class="headerlink" title="查询级别"></a>查询级别</h4><table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>const</td>
<td>性能排名第一；主键索引或者二级索引是unique key唯一索引进行的查询</td>
</tr>
<tr>
<td>ref</td>
<td>性能排名第二；二级索引是包含多个列的普通索引；查询语句需要满足最左侧列原则，然后必须都是等值比较</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>ref的一个特例；针对一个二级索引，比较了值还限定了IS NULL</td>
</tr>
<tr>
<td>range</td>
<td>性能排名第三；查询语句中有范围查询</td>
</tr>
<tr>
<td>index</td>
<td>性能排名第四；举例：假设表的联合索引是（x1,x2,x3），现在写一个SQL语句：select x1,x2,x3 from table where x2 = xxx，查询的字段刚好是联合索引中的字段，此时MySQL会直接遍历二级索引的叶结点，然后找到x2=xxx的那些数据，然后把x1,x2,x3的值提出来就ok了</td>
</tr>
<tr>
<td>all</td>
<td>性能最差；尽最大可能避免这种查询级别的发生</td>
</tr>
</tbody></table>
<h3 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h3><p>假设有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.x1<span class="operator">=</span>xxx <span class="keyword">and</span> t1.x2 <span class="operator">=</span> t2.x2 <span class="keyword">and</span> t2.x3 <span class="operator">=</span> xxx	</span><br></pre></td></tr></table></figure>

<p>MySQL会先根据t1.x1=xxx这个条件筛选，去t1表里去查出来一批数据，假设筛选出来了10条数据。然后用被筛选出来的这10条数据的x2的字段的值，依次到t2表中去匹配数据，匹配完后关联起来即可。</p>
<p>记住：<strong>先从一个表中查一波数据，这个表叫做“驱动表”（可能就是我们平时总说的主表），再根据这波数据区另外一个表里查一波数据，然后进行关联，另外这个表就叫做“被驱动表”。</strong></p>
<p>上述的多表关联的SQL的执行原理有一个名词可以对其进行描述：<strong>嵌套循环关联</strong>。嵌套循环关联在索引没有设计好的时候，会产生一些性能问题：</p>
<ul>
<li>首先，从驱动表中筛选第一波数据的时候，如果没有用上索引，会走全表扫描</li>
<li>其次，从驱动表中筛选出来第一波数据之后（假设筛选出了100条），会循环这些数据，然后到被驱动表中去查，此时如果驱动表又没加索引，又得在被驱动表中走个100次全表扫描</li>
<li>再其次，如果需要关联更多的表，对性能的影响就更是雪上加霜</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">JVM-Class文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 22:54:24" itemprop="dateCreated datePublished" datetime="2021-01-14T22:54:24+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-18 23:07:38" itemprop="dateModified" datetime="2021-01-18T23:07:38+08:00">2021-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114213638161.png" alt="image-20210114213638161" style="zoom:80%;">



<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Class文件采用一种类似于C语言的结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。</p>
<p><strong>无符号数</strong></p>
<p>基本的数据类型，以u1,u2,u4,u8来分别代表1、2、4、8个字节的无符号数。无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</p>
<p><strong>表</strong></p>
<p>由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的用<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由下表所示的数据项构成。</p>
<p>![Screen Shot 2019-05-31 at 9.45.25 AM](JVM-Class文件/Screen Shot 2019-05-31 at 9.45.25 AM.png)</p>
<h3 id="魔数和class文件版本信息"><a href="#魔数和class文件版本信息" class="headerlink" title="魔数和class文件版本信息"></a>魔数和class文件版本信息</h3><p>魔术用来标识是否是一个Class文件，Class文件的魔数用16进制标识是<code>CAFEBABE</code>。</p>
<p>版本信息分为次版本和主版本，主版本号从<code>45</code>开始，对应JDK1.1。</p>
<p>JDK1.1 &lt;——&gt; 45</p>
<p>JDK<strong>向下兼容</strong>旧版本的Class文件。例如，Class文件的major_version（主版本号）为0x34（52），则支持的JDK为，1 + (52 -45) = 8，也就是1.8以及1.8以上版本的JDK都可以执行这个Class文件。</p>
<blockquote>
<p>可见<strong>JVM是要和Class文件相兼容的</strong>。如果Class的主版本号过高导致JDK无法兼容，则会抛出“<em>java.lang.UnsupportedClassVersionError: Bad version number in .class file</em>”异常。</p>
</blockquote>
<p>另外，可以采用<code>javap -v $&#123;ClassFileName&#125; </code>来查看Class文件的版本号。</p>
<h3 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h3><p>首先要知道，常量池是由一组 <code>cp_info</code>结构体数组组成，暂且把这个数组叫做A。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114214609620.png" alt="image-20210114214609620" style="zoom:50%;">

<p>常量池计数器的作用主要是为常量池计数。他的数量是常量池中的常量的数量的值加一。例如，常量池中的常量的数量为100，那么这个计数器的值为101。<code>constant_pool</code>表的<strong>索引值</strong>只有在大于 0 且小于<code>constant_pool_count</code>时才会被认为是有效的。</p>
<blockquote>
<p>也就是说，常量池计数器的计数=A的长度。</p>
</blockquote>
<p>A的0号索引处的值被空出，当某些数据在特定的情况下想表达“<strong>不引用任何一个常量池项</strong>”的意思时，就可以将其引用的常量的索引值设置为0来表示。这也是常量池计数器大于等于一的原因。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>上边说到的<code>constant_pool</code>，其中表示的是一个<code>cp_info</code>数组，<code>cp_info</code>表示的是<strong>常量池项</strong>，下图表示的是其结构。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114215706024.png" alt="image-20210114215706024" style="zoom:50%;">





<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>用于表示某个类或者接口的<strong>访问权限</strong>及<strong>基础属性</strong>。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114220816073.png" alt="image-20210114220816073" style="zoom:50%;">

<p>表示这个 Class 文件所定义的类或接 口。</p>
<h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p><code>this_class</code>的值必须是constant_pool表的一个有效索引，索引处的类型为<code>Constant_Class_info</code>，表示这个 Class 文件所定义的类或接 口。</p>
<h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>父类索引，对于类来说，<code>super_class</code> 的值必须为 0 或者是对constant_pool 表中项目的一个有 效索引值。</p>
<p>如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为Constant_Class_info类型常 量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的 <code>access_flag</code> 中都不能带有<code>ACC_FINAL</code> 标记。对于接口来说，它的Class文件的super_class项的 值必须是对constant_pool表中项目的一个有效索引值，这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p>
<p>如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是 java.lang.Object类，只有它是唯一没有父类的类。</p>
<h3 id="接口计数器"><a href="#接口计数器" class="headerlink" title="接口计数器"></a>接口计数器</h3><p>接口计数器，interfaces_count的值表示当前类或接口的【直接父接口数量】。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口计数器的值为2。</p>
<h3 id="接口信息数据区"><a href="#接口信息数据区" class="headerlink" title="接口信息数据区"></a>接口信息数据区</h3><p><code>interfaces</code>每个成员的值必须是一个constant_pool的一个有效索引值，索引处所对应的值必须为 Constant_Class_info类型常量。interfaces的长度为 interfaces_count。在interfaces中，成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即interfaces[0]对 应的是源代码中最左边的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interfaces[0] 处的值引用constant_pool中的某个Constant_Class_info类型的常量，表示的是InterfaceA</p>
<p>interfaces[1] 处的值引用constant_pool中的某个Constant_Class_info类型的常量，表示的是InterfaceB</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114223641114.png" alt="image-20210114223641114" style="zoom:50%;">

<h3 id="字段计数器"><a href="#字段计数器" class="headerlink" title="字段计数器"></a>字段计数器</h3><p><code>fields_count</code>的值表示当前 Class 文件 fields的成员个数。 fields 中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String str0;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段计数器的值 = 2。</p>
<h3 id="字段信息数据区"><a href="#字段信息数据区" class="headerlink" title="字段信息数据区"></a>字段信息数据区</h3><p><code>fields</code>中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接 口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接 口继承的部分。</p>
<h3 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h3><p><code>methods_count</code>的值表示当前Class 文件 methods的成员个数。methods中每一项都是一个 method_info 结构的数据项。</p>
<h3 id="方法信息数据区"><a href="#方法信息数据区" class="headerlink" title="方法信息数据区"></a>方法信息数据区</h3><p><code>methods</code>中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。</p>
<p>如果某个method_info 结构的<code>access_flags</code>项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需 要引用其它类。</p>
<p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类 或接口初始化方法 。</p>
<blockquote>
<p>methods只描述当前类或接口中声明的方法，<strong>不包括从父类或父接口继承的方法</strong>。</p>
</blockquote>
<h3 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h3><p><code>attributes_count</code>的值表示当前 Class 文件attributes表的成员个数。 attributes表中每一项都是一个attribute_info 结构的数据项。</p>
<h3 id="属性信息数据区"><a href="#属性信息数据区" class="headerlink" title="属性信息数据区"></a>属性信息数据区</h3><p><code>attributes</code> 表的每个项的值必须是attribute_info结构。</p>
<p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性: </p>
<ul>
<li>InnerClasses </li>
<li>EnclosingMethod </li>
<li>Synthetic </li>
<li>Signature</li>
<li>SourceFile</li>
<li>SourceDebugExtension </li>
<li>Deprecated</li>
<li>RuntimeVisibleAnnotations </li>
<li>RuntimeInvisibleAnnotations</li>
<li>BootstrapMethods</li>
</ul>
<blockquote>
<p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的Signature、RuntimeVisibleAnnotations和 RuntimeInvisibleAnnotations属性。</p>
<p>对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。</p>
<p>Java 7 规范 要求 任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 (甚至全部) 它不可 识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息。</p>
</blockquote>
<h2 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h2><h3 id="常量池项的结构"><a href="#常量池项的结构" class="headerlink" title="常量池项的结构"></a>常量池项的结构</h3><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117195054266.png" alt="image-20210117195054266" style="zoom:50%;">



<h3 id="常量池项的结构-1"><a href="#常量池项的结构-1" class="headerlink" title="常量池项的结构"></a>常量池项的结构</h3><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117203550208.png" alt="image-20210117203550208" style="zoom:50%;">

<blockquote>
<p>cp_info会记录class文件中某种类型的字面量。JVM根据tag值确定cp_info表示什么类型的字面量</p>
</blockquote>
<p>tag有多种取值，<strong>不同tag值表示的不同结构</strong>。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117203849652.png" alt="image-20210117203849652" style="zoom:50%;">

<p>细化后的常量池结构</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220250754.png" alt="image-20210118220250754" style="zoom:50%;">





<h3 id="不同类型的常量池项的存储方式"><a href="#不同类型的常量池项的存储方式" class="headerlink" title="不同类型的常量池项的存储方式"></a>不同类型的常量池项的存储方式</h3><h4 id="int和float类型"><a href="#int和float类型" class="headerlink" title="int和float类型"></a>int和float类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220315591.png" alt="image-20210118220315591" style="zoom:50%;">

<p><code>CONSTANT_Integer_info</code>和<code>CONSTANT_Float_info</code>直接用四个字节进行数据的存储。</p>
<h4 id="long和double类型"><a href="#long和double类型" class="headerlink" title="long和double类型"></a>long和double类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220811792.png" alt="image-20210118220811792" style="zoom:50%;">

<p><code>CONSTANT_Long_info</code>和<code>CONSTANT_Double_info</code>直接用两个u4进行存储。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221207663.png" alt="image-20210118221207663" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221234164.png" alt="image-20210118221234164" style="zoom:50%;">

<p>由上两图可以看出，String类型相较于前两种类型的存储方式的不同之处在于：它并没有直接在<code>CONSTANT_String_info</code>中直接存储字符串的数据。它先用<code>CONSTANT_String_info</code>这种高级结构中的<code>tag</code>指定了cp_info的结构是String，然后用一个两字节的<code>string_index</code>存储了一个指向<code>CONSTANT_Utf8_info</code>结构的指针，在<code>CONSTANT_Utf8_info</code>中存储的了真正的字符串数据。</p>
<blockquote>
<p>问题：</p>
<p>为什么不在CONSTANT_String_info中，直接存储字符串数据呢？</p>
</blockquote>
<h4 id="类文件中定义的类名和类中使用到的类"><a href="#类文件中定义的类名和类中使用到的类" class="headerlink" title="类文件中定义的类名和类中使用到的类"></a>类文件中定义的类名和类中使用到的类</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118222511003.png" alt="image-20210118222511003" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221234164.png" alt="image-20210118221234164" style="zoom:50%;">

<p>与字符串的存储结构几乎相同。</p>
<h3 id="哪些字面量会被存储进常量池"><a href="#哪些字面量会被存储进常量池" class="headerlink" title="哪些字面量会被存储进常量池"></a>哪些字面量会被存储进常量池</h3><ol>
<li>final类型的8种<strong>基本类型</strong>的值会进入常量池。</li>
<li>非final类型(包括static的)的8种基本类型的值，只有<code>double</code>、<code>float</code>、<code>long</code>的值会进入常量 池。</li>
<li>字符串类型字面量(<strong>双引号</strong>引起来的字符串值)。</li>
</ol>
<h2 id="Class文件中的引用和特殊字符串"><a href="#Class文件中的引用和特殊字符串" class="headerlink" title="Class文件中的引用和特殊字符串"></a>Class文件中的引用和特殊字符串</h2><h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><p><strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，使用时能够正确的定义到目标即可。</strong></p>
<p>Java源代码会被编译为Class文件，在<strong>编译期</strong>可能无法得知当前类引用的累的地址，因此使用符号引用进行代替。符号引用在Class文件中的结构有以下几种：</p>
<ul>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Fieldref_info</li>
<li>CONSTANT_Methodref_info</li>
</ul>
<blockquote>
<p>猜想</p>
<p><code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>这两种结构应该跟<code>CONSTANT_Class_info</code>的存储方式是一致的。</p>
</blockquote>
<p>符号引用与虚拟机的内存布局无关，引用的目标不一定会被加载到内存当中。</p>
<h3 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h3><p>直接引用可以是：</p>
<ul>
<li>直接指向目标的指针（如：指向类方法的直接引用可能是指向方法区的指针）。</li>
<li>相对偏移量</li>
<li>一个能间接定义到目标的句柄</li>
</ul>
<p>直接引用与虚拟机的内存布局相关，上边所说的符号引用会被替换成直接引用，同一个符号引用在不同的虚拟机上被替换成的直接引用一般不会相同。<strong>如果有了直接引用，那么所引用的对象一定是已经被加载到内存当中了</strong>。</p>
<h3 id="符号引用替换成直接引用"><a href="#符号引用替换成直接引用" class="headerlink" title="符号引用替换成直接引用"></a>符号引用替换成直接引用</h3><h4 id="替换时机"><a href="#替换时机" class="headerlink" title="替换时机"></a>替换时机</h4><p>类的加载过程分为：</p>
<ol>
<li>加载</li>
<li>连接<ol>
<li>验证</li>
<li>准备</li>
<li>解析  *</li>
</ol>
</li>
</ol>
<p>解析阶段符号引用会被替换为直接引用。</p>
<h3 id="特殊字符串"><a href="#特殊字符串" class="headerlink" title="特殊字符串"></a>特殊字符串</h3><h5 id="类的完全限定名"><a href="#类的完全限定名" class="headerlink" title="类的完全限定名"></a>类的完全限定名</h5><h5 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h5><h6 id="各数据类型的描述符"><a href="#各数据类型的描述符" class="headerlink" title="各数据类型的描述符"></a>各数据类型的描述符</h6><h6 id="字段描述符"><a href="#字段描述符" class="headerlink" title="字段描述符"></a>字段描述符</h6><h6 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h6><h5 id="特殊方法的方法名"><a href="#特殊方法的方法名" class="headerlink" title="特殊方法的方法名"></a>特殊方法的方法名</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/13/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/13/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 20:25:45" itemprop="dateCreated datePublished" datetime="2021-01-13T20:25:45+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-22 15:20:12" itemprop="dateModified" datetime="2021-07-22T15:20:12+08:00">2021-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><p>操作系统太重了<img src="/techSnapshot.github.io/2021/01/13/Docker/v2-c20cb49c88034e73e09059668b8cecfb_1440w.jpg" alt="v2-c20cb49c88034e73e09059668b8cecfb_1440w" style="zoom:50%;"></p>
<p>操作系统重启是非常慢的</p>
<p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong></p>
<h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个：</p>
<ul>
<li>轻量级的</li>
<li>可移植的</li>
<li>自给自足的</li>
</ul>
<p>容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p>
<p>容器是一种通用技术，docker只是其中的一种实现。</p>
<h2 id="Docker拥有哪些能力？"><a href="#Docker拥有哪些能力？" class="headerlink" title="Docker拥有哪些能力？"></a>Docker拥有哪些能力？</h2><p>Docker提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。这样你的程序可以在任何环境都会有一致的表现，因此docker最重要的能力就是：<strong>可以屏蔽环境差异</strong>。</p>
<p>由于Docker具有屏蔽环境的差异的能力，由此衍生出了另外一个重要的应用能力：<strong>快速部署</strong>。只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。真正实现<strong>“build once, run everywhere”</strong>。</p>
<h2 id="我能用Docker干啥？"><a href="#我能用Docker干啥？" class="headerlink" title="我能用Docker干啥？"></a>我能用Docker干啥？</h2><ul>
<li>快速、一致的交付你的应用程序</li>
<li>响应式发布和扩展</li>
<li>在相同的硬件上能够运行更多的工作负载</li>
</ul>
<p>​    </p>
<h2 id="Docker引擎介绍"><a href="#Docker引擎介绍" class="headerlink" title="Docker引擎介绍"></a>Docker引擎介绍</h2><p>docker客户端</p>
<ul>
<li>SERVER（docker daemon）</li>
<li>REST API</li>
<li>CLI</li>
</ul>
<img src="/techSnapshot.github.io/2021/01/13/Docker/engine-components-flow.png" alt="engine-components-flow" style="zoom:80%;">

<blockquote>
<p>docker客户端和服务端一般运行在同一台机器上</p>
</blockquote>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><img src="/techSnapshot.github.io/2021/01/13/Docker/architecture.svg" alt="architecture" style="zoom:80%;">

<ul>
<li><p>The <strong>Docker daemon (</strong><code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p>
</li>
<li><p>The <strong>Docker client</strong> (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p>
</li>
<li><p>A <strong>Docker <em>registry</em></strong> stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.</p>
<p>When you use the <code>docker pull</code> or <code>docker run</code> commands, the required images are pulled from your configured registry. When you use the <code>docker push</code> command, your image is pushed to your configured registry.</p>
</li>
</ul>
<h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><p>docker中有这样几个概念：</p>
<ul>
<li>dockerfile：源程序</li>
<li>image：可执行程序</li>
<li>container：进程</li>
</ul>
<p>实际上你可以简单的把image理解为可执行程序，container就是运行起来的进程。</p>
<p>那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是”编译器”。</p>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
<h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>CentOS7</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker	</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CentOS7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/etc/docker/daemon.json</span></span><br><span class="line">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span><br></pre></td></tr></table></figure>



<h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有运行中的容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有容器，包括所有状态</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看最后一次创建的容器</span></span><br><span class="line">docker ps -l </span><br></pre></td></tr></table></figure>

<p>容器状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<h4 id="启停容器"><a href="#启停容器" class="headerlink" title="启停容器"></a>启停容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/<span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span>，然后输出结果。</span></span><br><span class="line">docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t: 在新容器内指定一个伪终端或终端。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</span></span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d：后台启动</span></span><br><span class="line">docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动已经停止的容器</span></span><br><span class="line">docker start &lt;容器Id&gt;</span><br><span class="line">docker restart &lt;容器Id&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">docker stop &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>

<p><strong>为什么Docker刚运行完run命令就停止了？</strong></p>
<blockquote>
<p>Docker 容器启动后，默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器是否正在运行的依据。<br>如果docker 容器pid=1进程挂了，那么docker容器便会直接退出。这样的话，如果我们在前台维持一个运行的进程，docker 容器就会一直处于运行的状态中。</p>
</blockquote>
<h4 id="监控容器"><a href="#监控容器" class="headerlink" title="监控容器"></a>监控容器</h4><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看日志</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1 查看标准输出</span></span><br><span class="line">docker logs &#123;容器ID或者容器名称&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">2 让docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</span></span><br><span class="line">docker logs -f &#123;容器ID或者容器名称&#125;  </span><br></pre></td></tr></table></figure>



<h5 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>



<h5 id="检查Docker"><a href="#检查Docker" class="headerlink" title="检查Docker"></a>检查Docker</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>



<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这种方式进入容器，<span class="built_in">exit</span>的时候，会将容器停止，不推荐使用</span></span><br><span class="line">docker attach &lt;容器Id&gt; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果从这个容器退出，容器不会停止，这就是为什么推荐使用 docker <span class="built_in">exec</span> 的原因</span></span><br><span class="line">docker exec -it &lt;容器Id&gt; /bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导出容器</span></span><br><span class="line">docker export &lt;容器Id&gt; &gt; ubuntu.tar</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">导入容器1</span></span><br><span class="line">cat docker/ubuntu.tar | docker import - test/ubuntu:v1</span><br><span class="line"><span class="meta">#</span><span class="bash">导入容器2</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>



<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除某个容器</span></span><br><span class="line">docker rm -f &lt;容器Id&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除所有处于终止状态的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure>



<h3 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h3><p>####列出所有镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<h4 id="运行某个镜像"><a href="#运行某个镜像" class="headerlink" title="运行某个镜像"></a>运行某个镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行某个镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t: 在新容器内指定一个伪终端或终端。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</span></span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d 在后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-P 与主机的高端口绑定</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--name 指定容器名称</span></span><br><span class="line">docker run -d -P --name runoob training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<h4 id="获取一个镜像"><a href="#获取一个镜像" class="headerlink" title="获取一个镜像"></a>获取一个镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>



<h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>



<h4 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>



<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure>



<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><h5 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动一个镜像，比如Ubuntu</span></span><br><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">做一些更新操作</span></span><br><span class="line">apt-get update </span><br><span class="line"><span class="meta">#</span><span class="bash">然后提交更新</span></span><br><span class="line">docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; &lt;Docker Id&gt; runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>

<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p><strong>Dockerfile</strong> 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。下边是一个Dockerfile的示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     useradd runoob</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>

<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</p>
<p>然后，使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t runoob/centos:6.7 .</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<h4 id="给镜像添加标签"><a href="#给镜像添加标签" class="headerlink" title="给镜像添加标签"></a>给镜像添加标签</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="number">860</span>c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>



<h3 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h3><h4 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line">docker run -d -p training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<p>也可以绑定主机的Ip地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>



<h5 id="绑定UDP端口"><a href="#绑定UDP端口" class="headerlink" title="绑定UDP端口"></a>绑定UDP端口</h5><p>端口后面加上 <strong>/udp</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure>



<h5 id="查看端口绑定情况"><a href="#查看端口绑定情况" class="headerlink" title="查看端口绑定情况"></a>查看端口绑定情况</h5><p><strong>docker port</strong> 命令可以让我们快捷地查看容器的端口的绑定情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看容器的5000端口是如主机的哪个端口相绑定</span></span><br><span class="line">docker port &lt;容器Id&gt; 5000</span><br></pre></td></tr></table></figure>



<h4 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h4><p>Docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>Docker 连接会创建一个<strong>父子关系</strong>，其中父容器可以看到子容器的信息。</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h5><ol>
<li>先创建一个新的 Docker 网络</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d：参数指定 Docker 网络类型，有 bridge、overlay。</span></span><br><span class="line">docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行一个容器并连接到新建的 test-net 网络，指定容器名称为test1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再运行一个容器并加入到 test-net 网络，指定容器名称为test2</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入容器test1去ping test2</span></span><br><span class="line">docker exec -it test1 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">没有ping命令则需要执行:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt install iputils-ping</span></span><br><span class="line">ping test2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">test2 ping test1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">操作同上</span></span><br></pre></td></tr></table></figure>



<h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><h5 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h5><p>CentOS上，Docker的配置文件在：/etc/docker/daemon.json这个位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完后，重启Docker。</p>
<p>查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm  ubuntu  cat etc/resolv.conf</span><br></pre></td></tr></table></figure>



<h5 id="指定容器配置"><a href="#指定容器配置" class="headerlink" title="指定容器配置"></a>指定容器配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br></pre></td></tr></table></figure>

<p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p>
<p><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p>
<p><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p>
<blockquote>
<p>如果在容器启动时没有指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p>
</blockquote>
<h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><p>仓库（Repository）是集中存放镜像的地方。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker search ubuntu</span><br><span class="line">docker pull ubuntu </span><br><span class="line">docker tag ubuntu:18.04 &lt;username&gt;/ubuntu:18.04</span><br><span class="line">docker push &lt;username&gt;/ubuntu:18.04</span><br><span class="line">docker search &lt;username&gt;/ubuntu</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure>



<h2 id="Docker工具"><a href="#Docker工具" class="headerlink" title="Docker工具"></a>Docker工具</h2><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<h4 id="Compose-三部曲"><a href="#Compose-三部曲" class="headerlink" title="Compose 三部曲"></a>Compose 三部曲</h4><ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">SpringBoot自动配置原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 22:15:40" itemprop="dateCreated datePublished" datetime="2021-01-08T22:15:40+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:06:38" itemprop="dateModified" datetime="2021-03-28T09:06:38+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Spring-Boot应用的启动入口"><a href="#Spring-Boot应用的启动入口" class="headerlink" title="Spring Boot应用的启动入口"></a>Spring Boot应用的启动入口</h4><p><strong>自动配置</strong>充分的利用了spring 4.0的条件化配置特性，那么，Spring Boot是如何实现自动配置的？Spring 4中的条件化配置又是怎么运用到Spring Boot中的呢？这要从Spring Boot的启动类说起。Spring Boot应用通常有一个名为<code>*Application</code>的入口类，入口类中有一个<code>main</code>方法，这个方法其实就是一个标准的Java应用的入口方法。一般在<code>main</code>方法中使用<code>SpringApplication.run()</code>来启动整个应用。值得注意的是，这个入口类要使用<code>@SpringBootApplication</code>注解声明。<code>@SpringBootApplication</code>是Spring Boot的核心注解，他是一个组合注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code>是一个组合注解，它主要包含<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>等几个注解。也就是说可以直接在启动类中使用这些注解来代替<code>@SpringBootApplication</code>注解。 关于Spring Boot中的Spring自动化配置主要是<code>@EnableAutoConfiguration</code>的功劳。该注解可以让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置。</p>
<p>至此，我们知道，Spring Boot的自动化配置主要是通过<code>@EnableAutoConfiguration</code>来实现的，因为我们在程序的启动入口使用了<code>@SpringBootApplication</code>注解，而该注解中组合了<code>@EnableAutoConfiguration</code>注解。所以，在启动类上使用<code>@EnableAutoConfiguration</code>注解，就会开启自动配置。</p>
<p>那么，本着刨根问底的原则，当然要知道<code>@EnableAutoConfiguration</code>又是如何实现自动化配置的，因为目前为止，我们还没有发现Spring 4中条件化配置的影子。</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration"></a>EnableAutoConfiguration</h4><p>其实Spring框架本身也提供了几个名字为<code>@Enable</code>开头的Annotation定义。比如<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code>等，<code>@EnableAutoConfiguration</code>的理念和这些注解其实是一脉相承的。</p>
<blockquote>
<p><code>@EnableScheduling</code>是通过<code>@Import</code>将Spring调度框架相关的bean定义都加载到IoC容器。</p>
<p><code>@EnableMBeanExport</code>是通过<code>@Import</code>将JMX相关的bean定义加载到IoC容器。</p>
<p><code>@EnableAutoConfiguration</code>也是借助<code>@Import</code>的帮助，将所有符合自动配置条件的bean定义加载到IoC容器。</p>
</blockquote>
<p>下面是<code>EnableAutoConfiguration</code>注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>@EnableAutoConfiguration</code>可以发现，这里<strong>Import</strong>了<code>@EnableAutoConfigurationImportSelector</code>，这就是Spring Boot自动化配置的“始作俑者”。</p>
<p>至此，我们知道，由于我们在Spring Boot的启动类上使用了<code>@SpringBootApplication</code>注解，而该注解组合了<code>@EnableAutoConfiguration</code>注解，<code>@EnableAutoConfiguration</code>是自动化配置的“始作俑者”，而<code>@EnableAutoConfiguration</code>中Import了<code>@EnableAutoConfigurationImportSelector</code>注解，该注解的内部实现已经很接近我们要找的“真相”了。</p>
<h4 id="EnableAutoConfigurationImport-Selector"><a href="#EnableAutoConfigurationImport-Selector" class="headerlink" title="EnableAutoConfigurationImport-Selector"></a>EnableAutoConfigurationImport-Selector</h4><p><code>EnableAutoConfigurationImportSelector</code>的源码在这里就不贴了，感兴趣的可以直接去看一下，其实实现也比较简单，主要就是使用Spring4 提供的的<code>SpringFactoriesLoader</code>工具类。通过<code>SpringFactoriesLoader.loadFactoryNames()</code>读取了ClassPath下面的<code>META-INF/spring.factories</code>文件。</p>
<blockquote>
<p>这里要简单提一下<code>spring.factories</code>文件，它是一个典型的java properties文件，配置的格式为<strong>Key = Value</strong>形式。</p>
</blockquote>
<p><code>EnableAutoConfigurationImportSelector</code>通过读取<code>spring.factories</code>中的key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>的值。如<code>spring-boot-autoconfigure-1.5.1.RELEASE.jar</code>中的<code>spring.factories</code>文件包含以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">......</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>上面的<code>EnableAutoConfiguration</code>配置了多个类，这些都是Spring Boot中的自动配置相关类；在启动过程中会解析对应类配置信息。每个<code>Configuation</code>都定义了相关bean的实例化配置。都说明了哪些bean可以被自动配置，什么条件下可以自动配置，并把这些bean实例化出来。</p>
<blockquote>
<p>如果我们新定义了一个starter的话，也要在该starter的jar包中提供 <code>spring.factories</code>文件，并且为其配置<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>对应的配置类。</p>
</blockquote>
<h4 id="Configuation"><a href="#Configuation" class="headerlink" title="Configuation"></a>Configuation</h4><p>我们从<code>spring-boot-autoconfigure-1.5.1.RELEASE.jar</code>中的<code>spring.factories</code>文件随便找一个Configuration，看看他是如何自动加载bean的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;JmxAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.application.admin&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationAdminJmxAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringApplicationAdminMXBeanRegistrar <span class="title">springApplicationAdminRegistrar</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;</span><br><span class="line">        String jmxName = <span class="keyword">this</span>.environment.getProperty(<span class="string">&quot;spring.application.admin.jmx-name&quot;</span>, <span class="string">&quot;org.springframework.boot:type=Admin,name=SpringApplication&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.mbeanExporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mbeanExporter.addExcludedBean(jmxName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationAdminMXBeanRegistrar(jmxName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到上面的代码，终于找到了我们要找的东西——Spring 4的条件化配置。上面<code>SpringApplicationAdminJmxAutoConfiguration</code>在决定对哪些bean进行自动化配置的时候，使用了两个条件注解：<code>ConditionalOnProperty</code>和<code>ConditionalOnMissingBean</code>。只有满足这种条件的时候，对应的bean才会被创建。这样做的好处是什么？这样可以保证某些bean在没满足特定条件的情况下就可以不必初始化，避免在bean初始化过程中由于条件不足，导致应用启动失败。</p>
<p>至此，我们可以总结一下Spring Boot的自动化配置的实现：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/r-20201030105053638.png" alt="img"></p>
<p>通过Spring 4的条件配置决定哪些bean可以被配置，将这些条件定义成具体的<code>Configuation</code>，然后将这些<code>Configuation</code>配置到<code>spring.factories</code>文件中，作为key: <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>的值，这时候，容器在启动的时候，由于使用了EnableAutoConfiguration注解，该注解Import的<code>EnableAutoConfigurationImportSelector</code>会去扫描classpath下的所有<code>spring.factories</code>文件，然后进行bean的自动化配置。</p>
<p>所以，如果我们想要自定义一个starter的话，可以通过以上方式将自定义的starter中的bean自动化配置到Spring的上下文中，从而避免大量的配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/SpringBoot%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/SpringBoot%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">SpringBoot核心概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 22:12:39" itemprop="dateCreated datePublished" datetime="2021-01-08T22:12:39+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:06:55" itemprop="dateModified" datetime="2021-03-28T09:06:55+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>纵然Spring已经能够为我们提供种种我们所需要的功能了，但是它依然还是不完美的。<strong>基于Spring的程序需要进行很多的配置</strong>。比如我们要开发web应用程序，我们需要考虑使用哪些Spring模块以及其他的框架，并且还需要考虑框架之间的版本是否兼容。除此之外，我们还要进行大量的基础配置，配置来配置去，这种重复操作总会让人闻到一股怀味道。</p>
<p>Spring的开发者们注意到了这些问题，于是Spring Boot诞生了。</p>
<p>Spring Boot通过两个方式使得我们从上述的重复操作中得以解脱：</p>
<ul>
<li>Spring Boot Auto Configuration</li>
<li>Spring Boot Starter Project</li>
</ul>
<h3 id="一、Spring-Boot-Starter-Project"><a href="#一、Spring-Boot-Starter-Project" class="headerlink" title="一、Spring Boot Starter Project"></a>一、Spring Boot Starter Project</h3><p>Spring Boot像是一个大管家，我们只需要告诉他，我们要做什么类型的程序，由他来负责帮助我们去做具体的事情。还是以web开发为例，我们只需要告诉Spring Boot我要干一个web项目，去给我准备相关的东西，Spring Boot就会去干事了。具体到操作上就是，我们提供给Spring Boot一个<strong>spring-boot-starter-web</strong>的选项，Spring Boot就会知道我们的意思，然后为我们生成出来一个工程，这个工程就已经具备了所有web应用程序开发所需要的所有依赖，完全没必要我们自己再去到pom中手动配置。Spring Boot的文档是这样解释的：</p>
<blockquote>
<p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xin.desertcamel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-starter-web</code> 一个起步依赖。通过Maven的依赖传递，可以得到一个web工程所需要的全部基础依赖。可以理解为，<code>Spring Boot为我们提供了一层高级抽象，屏蔽了底层细节，在这个实例代码中，开发者所应该关注的事情是我要做一个什么样的项目，要实现这个项目的功能需要依赖哪些功能，而不用再去关心我要具体依赖哪些库，起步依赖同时也管理了所要依赖的库的版本，让开发者从繁琐的包管理中解脱出来，而更关注应用程序的业务实现。</code></p>
<p><parent>标签的意义是，我们可以继承spring boot的一些默认的选项:</parent></p>
<ul>
<li><p>默认编译级别为Java 1.6</p>
</li>
<li><p>源码编码为UTF-8</p>
</li>
<li><p>一个依赖管理节点，允许你省略普通依赖的<version>标签。</version></p>
</li>
</ul>
<p>如果不想从spring boot parent继承，可以这样做：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="二、Spring-Boot-Auto-Configuration"><a href="#二、Spring-Boot-Auto-Configuration" class="headerlink" title="二、Spring Boot Auto Configuration"></a>二、Spring Boot Auto Configuration</h3><p>除了自动管理项目依赖之外，Spring Boot也提供了自动配置的能力。</p>
<p>当我们开发web应用程序时，我们需要在xml中或java以代码的形式来配置基于Spring的开发环境。比如我们需要配置Dispatcher Servlet、DataSource、ViewResolver等等这些必须的bean，这些操作每次都是重复的，所以Spring Boot就把它们也自动化掉了。Spring Boot会检测ClassPath当中的jar包，如果包含了web开发所需要使用jar包（Spring MVC），Spring就会把上述所说的配置都配置好，不用我们再去配置。同样贴上官方的解释：</p>
<blockquote>
<p><em>Spring Boot looks at a) Frameworks available on the CLASSPATH b) Existing configuration for the application. Based on these, Spring Boot provides basic configuration needed to configure the application with these frameworks. This is called</em> <code>Auto Configuration</code>.</p>
</blockquote>
<p>Spring Boot会根据类路径中的jar包、类，为jar包里的类自动配置，这样可以极大的减少配置的数量。简单点说就是它会根据定义在classpath下的类，自动的给你生成一些Bean，并加载到Spring的Context中。自动配置充分的利用了spring 4.0的条件化配置特性，能够自动配置特定的Spring bean，用来启动某项特性。</p>
<h4 id="条件化配置"><a href="#条件化配置" class="headerlink" title="条件化配置"></a>条件化配置</h4><p>假设你希望一个或多个bean只有在某种特殊的情况下才需要被创建，比如，一个应用同时服务于中美用户，要在中美部署，有的服务在美国集群中需要提供，在中国集群中就不需要提供。在Spring 4之前，要实现这种级别的条件化配置是比较复杂的，但是，<strong>Spring 4</strong>引入了一个新的<code>@Conditional</code>注解可以有效的解决这类问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional(ChinaEnvironmentCondition.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceBean <span class="title">serviceBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>@Conditional(ChinaEnvironmentCondition.class)</code>条件的值为true的时候，该<code>ServiceBean</code>才会被创建，否则该bean就会被忽略。</p>
<p><code>@Conditional</code>指定了一个条件。他的条件的实现是一个Java类——<code>ChinaEnvironmentCondition</code>，要实现以上功能就要定义<code>ChinaEnvironmentCondition</code>类，并继承<code>Condition</code>接口并重写其中的<code>matches</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaEnvironmentCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Environment env = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containProperty(<span class="string">&quot;ENV_CN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，matches方法的内容比较简单，他通过给定的<code>ConditionContext</code>对象进而获取<code>Environment</code>对象，然后使用该对象检查环境中是否存在<code>ENV_CN</code>属性。如果存在该方法则直接返回true，反之返回false。当该方法返回true的时候，就符合了<code>@Conditional</code>指定的条件，那么<code>ServiceBean</code>就会被创建。反之，如果环境中没有这个属性，那么这个<code>ServiceBean</code>就不会被创建。</p>
<p>除了可以自定义一些条件之外，Spring 4本身提供了很多已有的条件供直接使用，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Servlet容器、Spring容器、SpringMVC容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 21:29:03" itemprop="dateCreated datePublished" datetime="2021-01-08T21:29:03+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:02:57" itemprop="dateModified" datetime="2021-03-28T09:02:57+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>本文基于一个问题：在使用 SpringMVC 时，Spring 容器是如何与 Servlet 容器进行交互的？</strong></p>
</blockquote>
<h2 id="Spring-容器的加载"><a href="#Spring-容器的加载" class="headerlink" title="Spring 容器的加载"></a>Spring 容器的加载</h2><p>可否还记得，当年还没有 Springboot 的时候，在 Tomcat 的 web.xml 中进行面向 xml 编程的青葱岁月？其中有那么几段配置总是令我记忆犹新：</p>
<p>首先是 Spring 容器配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">  &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<p>其次是 Servlet 容器监听器配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>在 Tomcat 启动时，根据这两段配置，究竟做了什么动作，使得 Tomcat 与 Spring 完美地结合在一起了呢？</p>
<p>首先我们来看下 ContextLoaderListener 监听器的源码：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320205328.png" alt="img"></p>
<p>我们发现它继承了 ContextLoader，并且实现了 ServletContextListener 接口，下面说下这两个东西的作用：</p>
<ol>
<li>ContextLoader：正如其名，ContextLoader 可以在启动时载入 IOC 容器；</li>
<li>ServletContextListener：ServletContextListener 接口有两个抽象方法，contextInitialized 和 contextDestroyed，该监听器会结合 Web 容器的生命周期被调，ContextLoaderListener 正是实现了该接口。</li>
</ol>
<p>因此，ContextLoaderListener 最主要的作用就是在 Tomcat 启动时，根据配置加载 Spring 容器。</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320205759.png" alt="img"></p>
<p>以上就是 ContextLoaderListener 实现 contextInitialized 方法的逻辑，也是加载并初始化 Spring 容器的开始。</p>
<p>org.springframework.web.context.ContextLoader#initWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320210832.png" alt="img"></p>
<p>以上代码逻辑主要做了以下几个操作：</p>
<ol>
<li>调用 createWebApplicationContext 方法创建一个容器，会创建一个 contextClass 类型的容器，如果没有配置，则默认创建 WebApplicationContext 类型的容器；</li>
<li>将容器强转为 ConfigurableWebApplicationContext 类型；</li>
<li>调用 configureAndRefreshWebApplicationContext 方法初始化 Spring 容器；</li>
<li>最后将 Spring 容器，以一个元素的形式保存到 Servlet 容器中，这也就意味着，得到 Servlet 容器，同时也可以得到 Spring 容器。</li>
</ol>
<p>还发现 Spring 容器保存到 Servlet 容器中的 key 为 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们顺藤摸瓜找到获取 Spring 容器的方法：</p>
<p>org.springframework.web.context.support.WebApplicationContextUtils#getWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320220655.png" alt="img"></p>
<p>关于这个方法在哪里调用后面有说到。</p>
<p>org.springframework.web.context.ContextLoader#configureAndRefreshWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320210900.png" alt="img"></p>
<p>以上是 Spring 容器初始化逻辑，其中，CONFIG_LOCATION_PARAM 即是我们在 xml 中配置的 contextConfigLocation 参数：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320212506.png" alt="img"></p>
<p>同时还会将 Servlet 容器保存到 Spring 容器中，最后调用 refresh 方法进行初始化。</p>
<p>在将 Spring 容器初始化最后以一个元素的形式保存到 Servlet 容器之后，那么 SpringMVC 在初始化时，是如何拿到 Spring 容器的呢？</p>
<p>我们继续看 SpringMVC 初始化是怎么操作的。</p>
<h2 id="SpringMVC-容器的加载"><a href="#SpringMVC-容器的加载" class="headerlink" title="SpringMVC 容器的加载"></a>SpringMVC 容器的加载</h2><p>SpringMVC 本质上来讲，就是一个大号的 Servlet，其各种机制都是围绕着一个名叫 DispatcherServlet 的 Servlet 展开的，因此它必然实现了 Servlet 接口，那么在 Tomcat 启动时，它必然会通过 Servlet#init 方法进行初始化动作，我在其调用链路上发现以下方法：</p>
<p>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320220032.png" alt="img"></p>
<p>DispatcherServlet 的父类同样有一个方法，该方法是加载 SpringMVC 容器，即源码中的 webApplicationContext：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320221939.png" alt="img"></p>
<p>我们发现，rootContext 就是 ContextLoaderListener 加载的 <strong>Spring 容器</strong>，在这里，它会以父容器的身份保存到 SpringMVC 容器中。</p>
<p>当然，如果是用 Springboot 环境，那么默认只会存在一个上下文环境，原因如下：</p>
<p>1、在 Springboot 应用程序启动时，在 SpringBootServletInitializer#onStartup 方法中，会创建一个 rootAppContext 容器，如下：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320235338.png" alt="img"></p>
<p><strong>同时将上文所说的 ContextLoaderListener 监听器添加到 Servlet 容器中，同样达到了 xml 配置的效果</strong>，而调用 createRootApplicationContext 方法创建 rootAppContext 容器时，会将 contextClass 设置为 AnnotationConfigServletWebServerApplicationContext.class。</p>
<p>2、DispatcherServlet 此时作为一个 Bean，实现了 ApplicationContextAware 接口，会自动将上下文环境保存到 webApplicationContext 字段中；</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320233807.png" alt="img"></p>
<p>DispatcherServlet 初始化时，经过 debug 可以看到，rootContext 和 webApplicationContext 是同一个实例对象：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320231335.png" alt="img"></p>
<p>原因是通过 ContextLoaderListener 加载的上下文环境，通过 ApplicationContextAware 接口自动 set 进来保存到 DispatcherServlet 的 webApplicationContext 变量中了。</p>
<p>在 FrameworkServlet#initWebApplicationContext 方法最后，最终会将 webApplicationContext 注入以一个元素的形式保存到 Servlet 容器中：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320234137.png" alt="img"></p>
<h2 id="DispatcherServlet-初始化"><a href="#DispatcherServlet-初始化" class="headerlink" title="DispatcherServlet 初始化"></a>DispatcherServlet 初始化</h2><p>最终，SpringMVC 初始化会调用该方法：</p>
<p>org.springframework.web.servlet.DispatcherServlet#onRefresh</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200321000909.png" alt="img"></p>
<p>DispatcherServlet 初始化时，从 Spring 容器中获取相关 Bean，初始化各种不同的组件，比如初始化 HandlerMapping：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200321001725.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本质上来讲，Servlet 容器与 Spring 容器并不互通，但因为有 Servlet 容器的监听器 ServletContextListener，在它们之间构筑了桥梁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-10 13:59:32" itemprop="dateCreated datePublished" datetime="2019-05-10T13:59:32+08:00">2019-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 07:21:49" itemprop="dateModified" datetime="2021-03-29T07:21:49+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动态代理简介"><a href="#动态代理简介" class="headerlink" title="动态代理简介"></a>动态代理简介</h2><p><strong>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制</strong>。很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>代理模式以及装饰器模式的一种实现。能够实现<strong>调用者</strong>和<strong>实现者</strong>之间的<strong>解耦</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/techSnapshot.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/techSnapshot.github.io/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/techSnapshot.github.io/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/techSnapshot.github.io/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/techSnapshot.github.io/lib/anime.min.js"></script>
  <script src="/techSnapshot.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/techSnapshot.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/techSnapshot.github.io/js/utils.js"></script>

<script src="/techSnapshot.github.io/js/motion.js"></script>


<script src="/techSnapshot.github.io/js/schemes/muse.js"></script>


<script src="/techSnapshot.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
