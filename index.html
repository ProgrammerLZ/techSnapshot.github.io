<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/techSnapshot.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/techSnapshot.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/techSnapshot.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/techSnapshot.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/techSnapshot.github.io/css/main.css">


<link rel="stylesheet" href="/techSnapshot.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"programmerlz.github.io","root":"/techSnapshot.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="小楼昨夜又东风">
<meta property="og:url" content="https://programmerlz.github.io/index.html">
<meta property="og:site_name" content="小楼昨夜又东风">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liu">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://programmerlz.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>小楼昨夜又东风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/techSnapshot.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小楼昨夜又东风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/techSnapshot.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/techSnapshot.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Mysql最小知识集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-22 15:07:02 / 修改时间：15:19:03" itemprop="dateCreated datePublished" datetime="2021-07-22T15:07:02+08:00">2021-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Mysql架构设计(SQL接口、查询解析器、查询优化器、存储引擎、执行器)</li>
<li>Mysql日志相关(undo log、redo log、binlog)</li>
<li>Innodb存储引擎(buffer pool结构、free链表作用、flush链表作用、lru链表作用)</li>
<li>Mysql数据页/数据行/表空间/数据区</li>
<li>Mysql事务隔离级别/MVCC机制原理</li>
<li>索引原理/索引规则/索引优化</li>
<li>Explain执行计划分析</li>
</ol>
<h2 id="MySQL整体架构"><a href="#MySQL整体架构" class="headerlink" title="MySQL整体架构"></a>MySQL整体架构</h2><h3 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210506063443484.png" alt="image-20210506063443484" style="zoom:50%;">

<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210506063106059.png" alt="image-20210506063106059"></p>
<h3 id="生产经验"><a href="#生产经验" class="headerlink" title="生产经验"></a>生产经验</h3><h4 id="开发前期，与数据库紧密相关的准备工作"><a href="#开发前期，与数据库紧密相关的准备工作" class="headerlink" title="开发前期，与数据库紧密相关的准备工作"></a>开发前期，与数据库紧密相关的准备工作</h4><p>通过本小节，去大致的了解正规的互联网公司在开发前期，需要做哪些与数据库相关的准备工作</p>
<h4 id="数据库机器配置的选择"><a href="#数据库机器配置的选择" class="headerlink" title="数据库机器配置的选择"></a>数据库机器配置的选择</h4><h2 id="插曲：学习大纲"><a href="#插曲：学习大纲" class="headerlink" title="插曲：学习大纲"></a>插曲：学习大纲</h2><p>假设手上有了一个经过压测的、有了完善的监控系统的数据库开始，然后按照在在日常开发一个系统的流程当中使用数据库的顺序进行学习。</p>
<ol>
<li>增删改查的幕后原理，以及事务原理包括锁的底层机制</li>
<li>执行复杂查询时候，涉及到的索引底层原理，查询优化的底层原理</li>
<li>平时开发系统的时候，应该如何进行数据库建模，在数据库建模的时候应该如何注意字段类型、索引类型，如何保证数据库避免死锁高性能的运行</li>
<li>高阶的数据库架构设计<ol>
<li>主从架构设计</li>
<li>分库分表架构设计</li>
</ol>
</li>
</ol>
<p>在这个过程中会穿插着一些生产实践相关案例，这些也是非常宝贵的过来人的经验，要好好吸取。</p>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><h3 id="2-1-Buffer-Pool内存数据结构"><a href="#2-1-Buffer-Pool内存数据结构" class="headerlink" title="2.1 Buffer Pool内存数据结构"></a>2.1 Buffer Pool内存数据结构</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509075305294.png" alt="image-20210509075305294" style="zoom:50%;">

<h4 id="如何配置Buffer-Pool的大小"><a href="#如何配置Buffer-Pool的大小" class="headerlink" title="如何配置Buffer Pool的大小"></a>如何配置Buffer Pool的大小</h4><h4 id="数据页：MySQL中抽象出来的数据单位"><a href="#数据页：MySQL中抽象出来的数据单位" class="headerlink" title="数据页：MySQL中抽象出来的数据单位"></a>数据页：MySQL中抽象出来的数据单位</h4><h4 id="磁盘上的数据页与Buffer-Pool中的缓存页是如何对应起来的"><a href="#磁盘上的数据页与Buffer-Pool中的缓存页是如何对应起来的" class="headerlink" title="磁盘上的数据页与Buffer Pool中的缓存页是如何对应起来的"></a>磁盘上的数据页与Buffer Pool中的缓存页是如何对应起来的</h4><h4 id="缓存页中的描述信息是什么"><a href="#缓存页中的描述信息是什么" class="headerlink" title="缓存页中的描述信息是什么"></a>缓存页中的描述信息是什么</h4><h4 id="思考：关于Buffer-Pool中的内存碎片"><a href="#思考：关于Buffer-Pool中的内存碎片" class="headerlink" title="思考：关于Buffer Pool中的内存碎片"></a>思考：关于Buffer Pool中的内存碎片</h4><h3 id="2-2-free链表"><a href="#2-2-free链表" class="headerlink" title="2.2 free链表"></a>2.2 free链表</h3><h4 id="buffer-pool是如何被初始化的"><a href="#buffer-pool是如何被初始化的" class="headerlink" title="buffer pool是如何被初始化的"></a>buffer pool是如何被初始化的</h4><h4 id="如何知道哪些缓存页是空闲的"><a href="#如何知道哪些缓存页是空闲的" class="headerlink" title="如何知道哪些缓存页是空闲的"></a>如何知道哪些缓存页是空闲的</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509075623705.png" alt="image-20210509075623705" style="zoom:50%;">

<h4 id="free链表占多少内存空间"><a href="#free链表占多少内存空间" class="headerlink" title="free链表占多少内存空间"></a>free链表占多少内存空间</h4><h4 id="如何将磁盘上的页读到Buffer-Pool的缓存页里边去"><a href="#如何将磁盘上的页读到Buffer-Pool的缓存页里边去" class="headerlink" title="如何将磁盘上的页读到Buffer Pool的缓存页里边去"></a>如何将磁盘上的页读到Buffer Pool的缓存页里边去</h4><h4 id="怎么知道数据页有没有被缓存"><a href="#怎么知道数据页有没有被缓存" class="headerlink" title="怎么知道数据页有没有被缓存"></a>怎么知道数据页有没有被缓存</h4><p><strong>数据页哈希缓存</strong></p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509080415925.png" alt="image-20210509080415925" style="zoom:50%;">

<blockquote>
<p>缓存碎片：</p>
<p>Buffer Pool 将内存空间分配至缓存页和描述数据后，有可能会剩余一点内存空间什么都不够存放，这就产生了内存碎片。数据库，通过将缓存页和描述数据进行紧密的排列来减少缓存碎片。</p>
</blockquote>
<h3 id="2-3-flush链表"><a href="#2-3-flush链表" class="headerlink" title="2.3 flush链表"></a>2.3 flush链表</h3><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210509083205625.png" alt="image-20210509083205625" style="zoom:50%;">

<h4 id="脏数据页是如何产生的"><a href="#脏数据页是如何产生的" class="headerlink" title="脏数据页是如何产生的"></a>脏数据页是如何产生的</h4><h4 id="哪些缓存页是脏页"><a href="#哪些缓存页是脏页" class="headerlink" title="哪些缓存页是脏页"></a>哪些缓存页是脏页</h4><p>引入flush链表</p>
<h3 id="2-4-基于LRU算法淘汰部分缓存"><a href="#2-4-基于LRU算法淘汰部分缓存" class="headerlink" title="2.4 基于LRU算法淘汰部分缓存"></a>2.4 基于LRU算法淘汰部分缓存</h3><h4 id="Buffer-Pool中的缓存页不够用了怎么办？"><a href="#Buffer-Pool中的缓存页不够用了怎么办？" class="headerlink" title="Buffer Pool中的缓存页不够用了怎么办？"></a>Buffer Pool中的缓存页不够用了怎么办？</h4><h4 id="如果选择要淘汰掉的缓存，淘汰谁？"><a href="#如果选择要淘汰掉的缓存，淘汰谁？" class="headerlink" title="如果选择要淘汰掉的缓存，淘汰谁？"></a>如果选择要淘汰掉的缓存，淘汰谁？</h4><h4 id="缓存命中率概念的引入"><a href="#缓存命中率概念的引入" class="headerlink" title="缓存命中率概念的引入"></a>缓存命中率概念的引入</h4><h4 id="引入LRU链表来判断哪些缓存页是不常用的"><a href="#引入LRU链表来判断哪些缓存页是不常用的" class="headerlink" title="引入LRU链表来判断哪些缓存页是不常用的"></a>引入LRU链表来判断哪些缓存页是不常用的</h4><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h4 id="LRU在实际运行当中，可能导致的一些问题"><a href="#LRU在实际运行当中，可能导致的一些问题" class="headerlink" title="LRU在实际运行当中，可能导致的一些问题"></a>LRU在实际运行当中，可能导致的一些问题</h4><h5 id="导致频繁被访问的缓存页先被淘汰的两种情况"><a href="#导致频繁被访问的缓存页先被淘汰的两种情况" class="headerlink" title="导致频繁被访问的缓存页先被淘汰的两种情况"></a>导致频繁被访问的缓存页先被淘汰的两种情况</h5><ol>
<li>预读</li>
<li>全表扫描</li>
</ol>
<h5 id="什么时候会触发预读机制"><a href="#什么时候会触发预读机制" class="headerlink" title="什么时候会触发预读机制"></a>什么时候会触发预读机制</h5><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>MySQL的预读机制有什么作用？他加载一个数据页到缓存中去的时候为什么把一些相邻的数据页也加载到缓存里去呢？这样做的意义在哪里？这是为了应对怎么样的一个场景？</p>
<h3 id="MySQL对LRU算法的优化"><a href="#MySQL对LRU算法的优化" class="headerlink" title="MySQL对LRU算法的优化"></a>MySQL对LRU算法的优化</h3><h4 id="基于冷热数据的分离的方案对LRU算法进行优化"><a href="#基于冷热数据的分离的方案对LRU算法进行优化" class="headerlink" title="基于冷热数据的分离的方案对LRU算法进行优化"></a>基于冷热数据的分离的方案对LRU算法进行优化</h4><h5 id="基于冷热分离的思想设计LRU链表"><a href="#基于冷热分离的思想设计LRU链表" class="headerlink" title="基于冷热分离的思想设计LRU链表"></a>基于冷热分离的思想设计LRU链表</h5><p>冷数据</p>
<p>热数据</p>
<p>innodb_old_blocks_pct</p>
<h5 id="冷数据区域的缓存页什么时候会被放到热数据区域"><a href="#冷数据区域的缓存页什么时候会被放到热数据区域" class="headerlink" title="冷数据区域的缓存页什么时候会被放到热数据区域"></a>冷数据区域的缓存页什么时候会被放到热数据区域</h5><p>innodb_old_blocks_time</p>
<h5 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h5><h3 id="脏数据被刷回磁盘的方式"><a href="#脏数据被刷回磁盘的方式" class="headerlink" title="脏数据被刷回磁盘的方式"></a>脏数据被刷回磁盘的方式</h3><p><strong>定时把LRU链表尾部的部分刷入磁盘</strong></p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603173519976.png" alt="image-20210603173519976" style="zoom:30%;">



<p><strong>把flush链表中的部分缓存页刷入磁盘</strong></p>
<p>上述的后台线程，会在MySQL不怎么忙的时候，把flush链表中的数据都刷到磁盘中去。</p>
<p><strong>无缓存页时候的处理</strong></p>
<p>把LRU链表的冷数据区的尾部找到一个缓存页，将其刷入磁盘，然后将这个缓存页放到free链表中去</p>
<h2 id="数据页（MySQL存储的最小单位）"><a href="#数据页（MySQL存储的最小单位）" class="headerlink" title="数据页（MySQL存储的最小单位）"></a>数据页（MySQL存储的最小单位）</h2><p>一个数据页16kb，一个数据页被加载到Buffer Pool中就变成了缓存页。</p>
<p>数据页的结构如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603171510262.png" alt="image-20210603171510262" style="zoom:20%;">

<p>空闲区域用来存储一行一行的数据。</p>
<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>我们自己创建的表都有一个表空间的概念，再磁盘上都会对应着<strong>表名.ibd</strong>这样一个磁盘数据文件</p>
<p>数据页：最小单位 16kb</p>
<p>1个数据区（extent）=64个数据页  1mb</p>
<p>256个数据区被划分为一组  256mb</p>
<blockquote>
<p>每一组数据区的第一个数据区的前3个数据页都是存放了一些描述信息</p>
</blockquote>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603152226113.png" alt="image-20210603152226113" style="zoom:50%;">



<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210603193740827.png" alt="image-20210603193740827" style="zoom:30%;">



<p>redo log用于保证在一个事务被提交了之后，本次事务所做的操作一定会被反应到磁盘上。因为为了性能，MySQL的增删改查是针对BufferPool而不是磁盘进行操作，因此在事务提交之后有可能数据仍在缓存当中没有被刷新会磁盘，此时如果MySQL服务器突然宕机，缓存中的数据将会丢失。</p>
<p>针对这种情况，MySQL设计了redo log。Redo log用于记录本次事务当中所有对数据库的修改。写Redo log的方式是顺序写磁盘，每次都会追加到磁盘末尾（顺序写在这里不必纠结，就知道他很快就行了），因此写Redo log不会对MySQL性能有什么影响。</p>
<h3 id="Redo-log的结构"><a href="#Redo-log的结构" class="headerlink" title="Redo log的结构"></a>Redo log的结构</h3><p>如果是MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE类型的，其结构如下：</p>
<p>日志类型，表空间ID，数据页号，数据页中的偏移量，具体修改的数据</p>
<p>如果是MLOG_WRITE_STRING，其结构如下：</p>
<p>日志类型（MLOG_WRITE_STRING），表空间ID，数据页号，数据页中的偏移量，修改数据长度，具体修改的数据</p>
<h3 id="Redo-log的写入方式"><a href="#Redo-log的写入方式" class="headerlink" title="Redo log的写入方式"></a>Redo log的写入方式</h3><h4 id="存放Redo-Log的容器——Redo-Log-Block"><a href="#存放Redo-Log的容器——Redo-Log-Block" class="headerlink" title="存放Redo Log的容器——Redo Log Block"></a>存放Redo Log的容器——Redo Log Block</h4><p>MySQL中有另外一个数据结构——redo log block，用来存放多个单行的redo log。一个Redo Log Block是512字节，共分为3个部分：</p>
<ul>
<li><p>12字节的Header块头</p>
<p>​    Header块头又由4部分组成：</p>
<ul>
<li>4字节的block no</li>
<li>2字节的data length</li>
<li>2字节的first record group。每个事务都会有多个Redo Log，形成了一个Redo Log Group，group中的第一个Redo Log的偏移量就用这两个字节进行存储。</li>
<li>4字节的checkpoint on</li>
</ul>
</li>
<li><p>496字节的body块体</p>
</li>
<li><p>4字节的trailer块尾</p>
</li>
</ul>
<p>Redo Log Block的整体结构如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210615204720892.png" alt="image-20210615204720892" style="zoom:40%;">

<p>在写Redo Log的时候，现在内存当中把Redo Log写进一个Redo Log Block的数据结构当中去，当内存中的Redo Log Block的512个字节都写满了，再一次性把这个Redo Log Block写入磁盘。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210615205227672.png" alt="image-20210615205227672" style="zoom:50%;">



<h4 id="内存中的缓冲区-Redo-Log-Buffer"><a href="#内存中的缓冲区-Redo-Log-Buffer" class="headerlink" title="内存中的缓冲区-Redo Log Buffer"></a>内存中的缓冲区-Redo Log Buffer</h4><p>Redo Log Buffer是MySQL启动的时候就跟操作系统申请的一块内存空间。Redo Log Buffer与Buffer Pool类似，也是申请出来一片连续的内存，然后里边划分出了N多个空的Redo Log Block，如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618203402331.png" alt="image-20210618203402331" style="zoom:40%;">

<p>可以通过<strong>innodb_log_buffer_size</strong>来指定Redo Log Buffer的大小，其默认大小为<strong>16MB</strong>。这已经足够大了，毕竟一个Redo Log Block才512 字节，一个 Redo Log一般情况下最大可能也就几十个字节。</p>
<p>Redo Log会被先写入内存中Redo Log Buffer，从Redo Log Buffer中的第一个Redo Log Block开始写起。MySQL会对这块Redo Log Buffer有一定的刷盘策略，这个在下一小节详细记录。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618204147687.png" alt="image-20210618204147687" style="zoom:40%;">

<p>在一个事务中，会有多个增删改的操作，那么就会有多个Redo Log，他们组成了一组Redo Log，也就是<strong>Redo Log Group</strong>，每一组Redo Log都会在一个地方暂存，事务执行完了，再把一组Redo Log写入到Redo Log Buffer中去。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618204513902.png" alt="image-20210618204513902" style="zoom:40%;">



<h4 id="Redo-Log-Buffer中的Redo-Log的刷盘时机"><a href="#Redo-Log-Buffer中的Redo-Log的刷盘时机" class="headerlink" title="Redo Log Buffer中的Redo Log的刷盘时机"></a>Redo Log Buffer中的Redo Log的刷盘时机</h4><ol>
<li>Redo Log Buffer的容量如果已经使用了一半了，也就是超过了8MB，此时就会把他们刷入到磁盘文件中去</li>
<li>一个事务提交的时候，必须把这个事务对应的Redo Log Group所在的Redo Log Block刷入到磁盘文件中去</li>
<li>后台线程定时刷新，每隔1秒就会把Redo Log Buffer中的Redo Log Block刷到磁盘文件中去</li>
<li>MySQL关闭的时候，Redo Log Block都会刷入到磁盘文件中去</li>
</ol>
<p>如果产生了高并发，1s中就产生了超过8MB的Redo Log，此时必然会触发第一个刷盘条件。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210618205746496.png" alt="image-20210618205746496" style="zoom:40%;">

<p>平时一个事务一般都是在几十到几百毫秒之间执行完的，事务执行完毕则会触发第二个刷盘条件。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619121729679.png" alt="image-20210619121729679" style="zoom:40%;">



<h4 id="磁盘Redo-Log文件的大小控制"><a href="#磁盘Redo-Log文件的大小控制" class="headerlink" title="磁盘Redo Log文件的大小控制"></a>磁盘Redo Log文件的大小控制</h4><p>Redo Log都会写进一个目录中的文件里，可以通过<code>show_viriables like &#39;datadir&#39;</code>来查看这个目录。默认有两个这样的文件，分别为ib_logfile0和ib_logfile1，写满了一个文件就会写下一个文件，其默认大小是<strong>48MB</strong>。默认情况下，如果两个文件都写满了，会继续写入第一个文件，也就是ib_logfile0，并且会覆盖ib_logfile0中之前写入的Redo Log，所以MySQL在默认情况下，只会保留最近的96MB的Redo Log。</p>
<p>MySQL也提供了几个参数来修改默认的设置：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_log_file_size</td>
<td>指定每个Redo Log文件大小</td>
</tr>
<tr>
<td>innodb_log_files_in_group</td>
<td>指定Redo Log文件的数量</td>
</tr>
<tr>
<td>innodb_log_group_home_dir</td>
<td>指定Redo Log文件的存放目录</td>
</tr>
</tbody></table>
<h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>Undo Log主要用在事务的回滚上。当一个事务在执行完之前想要回滚，Undo Log就起到了他的作用，如下图：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619171015437.png" alt="image-20210619171015437" style="zoom:40%;">

<p>从最抽象的顶层来看，Undo Log记录的内容很简单，分增删改三种：</p>
<ul>
<li>insert：会记录一个主键和一个对应的delete操作</li>
<li>delete：会把删除的那条数据记录下来</li>
<li>update：会把更新前的那个值记录下来</li>
</ul>
<h3 id="剖析Insert语句的Undo-Log"><a href="#剖析Insert语句的Undo-Log" class="headerlink" title="剖析Insert语句的Undo Log"></a>剖析Insert语句的Undo Log</h3><p>一条Inser语句的Undo Log包括以下内容：</p>
<ul>
<li><p>这条日志的开始位置</p>
</li>
<li><p>主键的各列长度和值</p>
</li>
<li><p>表Id</p>
</li>
<li><p>Undo Log 日志编号</p>
<p>每个Undo Log都有自己的编号，每个事物里的Undo Log日志的编号都是从0开始的，依次递增。</p>
</li>
<li><p>Undo Log日志类型</p>
<p>Inser 语句的Undo Log的日志类型是：<strong>TRX_UNDO_INSERT_REC</strong></p>
</li>
<li><p>这条日志的结束位置</p>
</li>
</ul>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619172815970.png" alt="image-20210619172815970"></p>
<h2 id="多事务并发"><a href="#多事务并发" class="headerlink" title="多事务并发"></a>多事务并发</h2><p>MySQL的多事务并发示意图如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210619174648835.png" alt="image-20210619174648835" style="zoom:40%;">

<p>在多事务并发的情况下会产生很多的问题，比如：</p>
<ul>
<li>对Buffer Pool中的同一行数据进行更新的时候，这个冲突怎么处理？</li>
<li>可能有事务事务在对一行数据做更新，但是另外一个事务在查询折行数据，这个冲突又怎么处理？</li>
</ul>
<p>说白了就是，<strong>在多事务并发的时候，MySQL应该如何合理的分配资源</strong>。</p>
<p>接下来，在多事务并发这一节中主要围绕的就是对于资源冲突的情况，MySQL内部的一些处理机制是怎样的，包括：</p>
<ul>
<li>事务的隔离级别</li>
<li>MVCC多版本隔离</li>
<li>锁机制</li>
</ul>
<h3 id="多事务并发会导致的4种常见问题"><a href="#多事务并发会导致的4种常见问题" class="headerlink" title="多事务并发会导致的4种常见问题"></a>多事务并发会导致的4种常见问题</h3><h4 id="1-脏写"><a href="#1-脏写" class="headerlink" title="1. 脏写"></a>1. 脏写</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620134633714.png" alt="image-20210620134633714" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620134706929.png" alt="image-20210620134706929" style="zoom:50%;">

<p>事务B明明自己已经把一行记录更新了，但是值却没了，这就是脏写。</p>
<blockquote>
<p>脏写其实就是，对于任意一个事务，写入的某行记录的值随时可能被其他事务更改。</p>
</blockquote>
<h4 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135254424.png" alt="image-20210620135254424" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135311181.png" alt="image-20210620135311181" style="zoom:50%;">

<p>事务B第一次查出来的是A值，然后拿着A这个值去做各种业务处理，但是第二次再去查询的时候该值变成了NULL。</p>
<blockquote>
<p>脏读其实就是，对于任意事务，当前读出来的值在以后可能被其他事务所更改。</p>
</blockquote>
<h4 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135845983.png" alt="image-20210620135845983" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135901501.png" alt="image-20210620135901501" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620135930844.png" alt="image-20210620135930844" style="zoom:50%;">

<p>事务A每次读出来的值都是不一样的，这就叫做不可重复读。</p>
<p>不可重复度这个问题不一定会对业务系统产生影响，这取决于业务系统的要求。如果每次读出来的值都是不一样的，但是对于业务系统来说这没什么问题，那么不可重复读就是一种正常现象。但是如果希望事务开始之后，对于同一行记录，读到的值自始至终都是一样的，那么不可重复读就会对业务系统产生影响。</p>
<p><strong>因此，不可重复读是否会产生影响，取决于业务系统的要求。</strong></p>
<h4 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h4><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620140653915.png" alt="image-20210620140653915" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210620140713230.png" alt="image-20210620140713230" style="zoom:50%;">

<p>事务A用<strong>一模一样的SQL语句</strong>进行了两次查询，查询出来的结果是不一样的，这就是幻读。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</p>
<h4 id="不可重复读VS幻读"><a href="#不可重复读VS幻读" class="headerlink" title="不可重复读VS幻读"></a>不可重复读VS幻读</h4><p>在学习的过程当中我对不可重复读和幻读没法完全的将这两个现象拆分开，现在就把这两种现象放在一块做一下分析。</p>
<p>从表征上来看，不可重复读和幻读的结果都是两次读取产生的结果不一样，但是如果进入到细节来看，可以发现他们还是有区别的。不可重复读，两次读取的结果不一样的地方在于两次读取的<strong>值</strong>不一样，重点在于读取的值，也就是其他事物的update操作和delete操作会对其产生影响，而insert却没什么影响；幻读，两次读取的结果不一样的地方在于两次读取的结果数量不一样，也就是其他事务的insert操作和delete操作对其会产生影响，而update却没什么影响。</p>
<blockquote>
<p>幻读和不可重复读的理解，暂时先止于此，可能理解上有误，但不耽误接下来的学习。</p>
</blockquote>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li>读未提交（read uncommitted）（此事务还没提交，别人就能读到在该事务中更新后的结果），一个事务还没提交时，它做的变更就能被别的事务看到，该隔离级别可以避免脏写。</li>
<li><strong>读提交（read committed，RC）</strong>（此事务还没提交，别人无法读到在该事务中更新后的结果），一个事务提交之后，它做的变更才会被其他事务看到，改革立级别可以避免脏写和脏读。</li>
<li><strong>可重复读（repeatable read，RR）</strong>（别人做的任何数据更改，不影响本事务，本事务始终读的都是事务开始时候的快照），一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的，该隔离级别可避免不可重复读，但不能避免幻读。</li>
<li>串行化（serializable），顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>在MySQL当中，默认的隔离级别是RR级别，也就是说使用MySQL默认隔离级别就能避免幻读，这依靠了他的MVCC机制——多版本并发控制隔离机制，之后会详细记录这个MVCC，这是一个重点内容。</p>
<h3 id="MVCC前奏，Undo-Log版本链"><a href="#MVCC前奏，Undo-Log版本链" class="headerlink" title="MVCC前奏，Undo Log版本链"></a>MVCC前奏，Undo Log版本链</h3><p>简单来说，数据库中的没条记录都存在两个隐藏字段：</p>
<ul>
<li>trx_id</li>
<li>roll_pointer</li>
</ul>
<p>trx_id就是最近更新这条数据的事务Id，roll_pointer指向了最近的一个事务对这条记录进行改动的Undo Log。举例来说：</p>
<p>事务A，id为50，在数据库中插入了一条数据，那么此时这条数据的trx_id为50，roll_pointer指向了一个空的Undo Log。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621200649616.png" alt="image-20210621200649616" style="zoom:50%;">

<p>接着，事务B，id为58，更新了这条记录，那么此时这条数据的trx_id为58，roll_pointer指向了事务A生成的Undo Log，图中的Undo Log只画出来了Undo Log的一部分内容——也就是事务B更新这条记录之前的值，包括了这条记录所有的字段的值，其他部分没有画出来因为并不影响理解。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621201835298.png" alt="image-20210621201835298" style="zoom:50%;">

<p>接着，事务C，跟事务B一样，不再赘述。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621204053849.png" alt="image-20210621204053849" style="zoom:50%;">

<p>以上，在事务串行的场景下，记录了MySQL的Undo Log版本链，Undo Log版本链是MVCC的基础。</p>
<h3 id="基于Undo-Log版本链实现的ReadView机制"><a href="#基于Undo-Log版本链实现的ReadView机制" class="headerlink" title="基于Undo Log版本链实现的ReadView机制"></a>基于Undo Log版本链实现的ReadView机制</h3><p>ReadView，简单来说就是你执行一个事务的时候，就会生成一个<strong>ReadView</strong>，里边有比较关键的4个东西：</p>
<ul>
<li><strong>m_ids</strong>，数据库中还没有提交的事务的id——可以认为这是事务是与本事务并发执行的事务</li>
<li><strong>min_trx_id</strong>，m_ids里的最小值</li>
<li><strong>max_trx_id</strong>，数据库中下一个要生成的事务的id，也就是m_ids里的最大值</li>
<li><strong>creator_id</strong>，当前这个事务的id</li>
</ul>
<p>下边通过举例，来描述ReadView是如何使用的。</p>
<ol>
<li>数据库中有一条最原始的记录是这样的：</li>
</ol>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205330262.png" alt="image-20210621205330262" style="zoom:30%;">

<ol start="2">
<li>接着来了两个事务，事务A、事务B。事务A要读取这行记录，事务B要更新这条记录，此时事务A的ReadView的情况为：</li>
</ol>
<ul>
<li>m_ids = [45,59]</li>
<li>min_trx_id = 45</li>
<li>max_tr_id = 59</li>
<li>creator_id = 45</li>
</ul>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205457917.png" alt="image-20210621205457917" style="zoom:50%;">

<ol start="3">
<li>事务A在查询该记录的时候，会判断该记录中的trx_id是否小于ReadView中的min_trx_id，发现记录的trx_id = 32,ReadView中的min_trx_id=45，这说明在ReadView生成的时候，id为32的事务就已经提交了，因此是事务A能够正常查询到这条记录的的原始值：</li>
</ol>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210621205646584.png" alt="image-20210621205646584" style="zoom:50%;">

<ol start="4">
<li>接着，事务B开始更新这条数据，把数据的值更新成了B，trx_id更新成了自的id——也就是59，同时roll_pointer指向了一个Undo Log，该Undo Log记录了更新前的记录。最后，事务B提交。</li>
</ol>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627123722779.png" alt="image-20210627123722779"></p>
<ol start="5">
<li>然后，事务A又来查询，此时事务A发现了几个事情：</li>
</ol>
<ul>
<li>这条数据的trx_id = 59，比ReadView中的min_trx_id大，这说明：<strong>自己的事务开启之后，这条记录被事务Id为59的事务更新过并且该事务已经提交</strong></li>
<li>这条数据的trx_id = 59，比ReadView中的max_trx_id小，这说明：<strong>更新这条记录的这个事务基本上是跟自己同时开启的</strong></li>
<li>这条数据的trx_id = 59，m_ids = [45,59]，trx_id存在与m_ids中，<strong>直接证明该事务是与本事务同期并发执行的事务</strong></li>
</ul>
<p>此时，A得出了结论，<strong>该记录不能读</strong>。于是，A顺着roll_pointer找到了最近的那个Undo Log，trx_id是32，发现：</p>
<ul>
<li>该Undo Log的trx_id是32，比ReadView中的minx_trx_id小，这说明：<strong>这个Undo Log的版本必然是在事务A开启之前就执行切提交的。</strong></li>
</ul>
<p>此时，A会从这个Undo Log中读取到原始值。</p>
<p>这就是Undo Log版本链的作用，<strong>他可以保存数据的一个版本链条，让你可以读到数据之前的快照中的值。</strong></p>
<blockquote>
<p>这里遗留了一个问题：Undo Log版本链中的Undo Log不可能无限增加吧，那么他是什么时候被删除的呢？</p>
</blockquote>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627151926578.png" alt="image-20210627151926578"></p>
<ol start="6">
<li><p>接着，A自己更新了这条记录。</p>
<ul>
<li>将记录的改成了值A；trx_id修改为45；同时保存本次更新前的记录的快照；</li>
</ul>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152258485.png" alt="image-20210627152258485"></p>
</li>
<li><p>然后，A自己再来查询这条记录，发现：</p>
<ul>
<li>这调数据的trx_id是45，与ReadView中的creator_id相同，这说明：<strong>这条数据就是自己改的</strong></li>
</ul>
<p>因此，A得出结论，这条记录是可以读的。</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152519540.png" alt="image-20210627152519540"></p>
</li>
<li><p>接着，事务A还没有提交，又来个事务C，这个事务的id是78，将这条记录的值更新成了值C并提交：</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627152734979.png" alt="image-20210627152734979"></p>
</li>
<li><p>事务A此时再来查询，发现：</p>
<ul>
<li>当前数据的trx_id=78，比ReadView中的max_trx_id大，这说明：<strong>在事务A开启之后，事务C更新了数据</strong></li>
</ul>
<p>因此，事务A得出结论：该数据记录不可读，于是顺着roll_pointer开始寻找可读数据，就找到了值为A的那条记录，于是就读到了值A。</p>
</li>
</ol>
<blockquote>
<p>这里有一点自己的思考：</p>
<p>一个事务的开启应该是包含了几个固定的过程，其中就包含m_ids，min_trx_id，max_trx_id，creator_id这几个值捕获这个过程，这个过程会捕获所有当前事务开启时的正在活跃中的事务Id。当这几个固定的过程都完成后，一个事务才算是开启。因此，当发现一条记录的trx_id比自己m_ids中的最大id还大的时候，就完全能够说明这个事务是在本事务开启之后开启的。</p>
</blockquote>
<p><strong>RC级别是如何基于ReadView机制实现的</strong></p>
<p>RC隔离级别，是本事务可以读其他事务已更新并且已提交了的值。该隔离级别的实现原理就是：</p>
<p><strong>在一个事务中，每次读取操作，都会生成一个ReadView。</strong></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155440120.png" alt="image-20210627155440120"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155517384.png" alt="image-20210627155517384"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155558291.png" alt="image-20210627155558291"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627155857805.png" alt="image-20210627155857805"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627160137458.png" alt="image-20210627160137458"></p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627160205957.png" alt="image-20210627160205957"></p>
<h3 id="脏写是如何被避免的"><a href="#脏写是如何被避免的" class="headerlink" title="脏写是如何被避免的"></a>脏写是如何被避免的</h3><p>MVCC是用来解决多事务并发的时候，读操作与其他事务的写操作之间的协调问题。而数据库的锁机制，是用来解决多个事务同时更新同一条记录时候，产生的脏写的问题。</p>
<p>老样子，继续举例说明。</p>
<ol>
<li><p>当一个事务A想要更新某条记录的时候，他会先看看这行数据此时有没有被其他事务加锁。如果没人加锁，那说明这条记录本事务是可以更新的，于是该事务会新建一个锁，锁中包含了：</p>
<ul>
<li><p>事务的trx_id = 50</p>
</li>
<li><p>等待状态 = false</p>
</li>
</ul>
<p>然后，把该锁跟要更新的那条数据关联起来：</p>
</li>
</ol>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627164105180.png" alt="image-20210627164105180"></p>
<ol start="2">
<li>此时，事务B也想更新这条记录，发现这条记录已经被加锁了，于是事务B也在内存中产生了一个锁数据结构，所数据结构中的各项状态为：</li>
</ol>
<ul>
<li>事务的trx_id = 60</li>
<li>等待状态 = true</li>
</ul>
<p>然后等着该条记录的锁被释放就行了。</p>
<p>注意，事务B的等待状态是true。</p>
<p><img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210627164832979.png" alt="image-20210627164832979"></p>
<ol start="3">
<li>接着，事务A更新完了数据，会释放掉锁，然后去找此时还有没有其他人也对这行记录加了锁，发现B也对这行记录加了锁，于是将B的等待状态改为false，接着唤醒B事务继续执行，此时事务B就获取到锁了。</li>
</ol>
<h3 id="行级锁：共享锁和独占锁"><a href="#行级锁：共享锁和独占锁" class="headerlink" title="行级锁：共享锁和独占锁"></a>行级锁：共享锁和独占锁</h3><p>上一小节讲到的更新操作加的锁实际上是一种<strong>独占锁</strong>，而独占锁对于默认的读操作来说是透明的，因为读操作走的是MVCC机制，满足了MVCC机制就必然能够去读这行数据，完全不用考虑是否有其他事务正在更新这条数据。读操作默认情况下走MVCC机制，完全不考虑锁的情况，因此读操作默认情况下也不会对要读的记录加锁。</p>
<p>但是，<strong>MySQL也对读操作的时候加读锁提供了支持</strong>。</p>
<p>首先是读操作时候的共享锁。可以在一个查询语句的最后加上<code>lock in share mode</code>，意思就是在查询的时候对这行记录加上共享锁。但是共享锁跟独占锁是互斥的，若此时这条记录已经加上了独占锁，该查询就只能处于等待状态了。共享锁和共享锁之间是不互斥的，也就是说同一条记录，两个事务都来加共享锁是没问题的，两个事务都不会等待，直接就可以读取这条记录的值。</p>
<blockquote>
<p>看来，读操作的时候加的共享锁，就是为了排斥更新操作的，我读的时候别人不能更新。</p>
</blockquote>
<p>然后是读操作时候的独占锁。可以在一个查询语句的最后加上<code>for update</code>，意思就是在查询的时候对这行记录加上独占锁。读操作时候的独占锁代表的是，这条数据我查出来之后还要更新，其他人不要更新这条数据了。</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>独占锁</th>
<th>共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>独占锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>共享锁</td>
<td>互斥</td>
<td>不互斥</td>
</tr>
</tbody></table>
<p>读操作的时候手动的加锁这种情况是很少见的，一般不会在数据库层面做复杂的手动加锁的操作，因为在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁分为两种：</p>
<ul>
<li>表锁</li>
<li>表级意向锁</li>
</ul>
<p>首先说说表锁，表锁的添加语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--表级共享锁</span><br><span class="line">LOCK TABLE XXX READ</span><br><span class="line">--表级独占锁</span><br><span class="line">LOCK TABLE XXX WRITE</span><br></pre></td></tr></table></figure>

<p>表锁不常用，很少会手动的去加表锁。</p>
<p>然后说说表级意向锁，意向锁都是<strong>自动加上去</strong>的。有两种情况会加表级意向锁：</p>
<ul>
<li>有事务在做<strong>增删改</strong>操作的时候，除了会在行级加独占锁，同时也会在表级加意向独占锁</li>
<li>有事务在做查询操作的时候，会在表中加一个意向共享锁</li>
</ul>
<p>这两种锁都是在执行增删改查的时候自动在表级加的锁，他们之间是不存在互斥关系的，彼此互相透明，谁也看不见谁。然而，他们和手动加的表级所是存在互斥关系的，互斥关系如图：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>手动加的表级共享锁</th>
<th>手动加的表级独占锁</th>
<th>意向独占锁</th>
<th>意向共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>手动加的表级共享锁</td>
<td>不互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>不互斥</td>
</tr>
<tr>
<td>手动加的表级独占锁</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>意向独占锁</td>
<td>互斥</td>
<td>互斥</td>
<td>不互斥</td>
<td>不互斥</td>
</tr>
<tr>
<td>意向共享锁</td>
<td>不互斥</td>
<td>互斥</td>
<td>不互斥</td>
<td>不互斥</td>
</tr>
</tbody></table>
<h3 id="案例实战：线上数据库的随机性能抖动优化"><a href="#案例实战：线上数据库的随机性能抖动优化" class="headerlink" title="案例实战：线上数据库的随机性能抖动优化"></a>案例实战：线上数据库的随机性能抖动优化</h3><p>先说引起抖动的可能的原因：</p>
<ul>
<li>一个查询语句，需要查询大批量的数据，导致需要将Buffer Pool中的脏页大量刷入磁盘，才能空余出空间来执行这条SQL语句。</li>
<li>所有Redo Log文件都写满了，需要开始覆盖第一个Redo Log文件中的Redo Log，此时会检查如果第一个Redo Log文件里边的一些redo log对应之前更新过的Buffer Pool中的缓存页，迄今为止都没刷入磁盘，此时必须要把那些马上那些缓存页刷入磁盘。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>尽量减少缓存页flush到磁盘的频率</p>
</li>
<li><p>尽量提升缓存页flush到磁盘的速度</p>
</li>
</ul>
<p>减少频率很困难，着重放在第二个解决方案上。</p>
<p>要提升缓存页flush到磁盘的速度，通常的建议就是：<strong>对于数据库部署的机型，采用SSD固态硬盘，而不是机械硬盘，SDD固态硬盘最强大的地方，就是他的随机IO性能非常高。</strong></p>
<p>flush缓存页到磁盘，是典型的随机IO，需要在磁盘上找到各个缓存页所在的随机位置，把数据写入到磁盘里去。所以如果采用的是SSD固态硬盘，那么flush缓存页到磁盘的性能首先就会有很大的提高。</p>
<p>光用SSD还不够，还必须要设置MySQL一个非常关键的参数：<code>innodb_io_capacity</code>，这个参数就是告诉数据库采用多大的IO速率吧缓存页flush到磁盘中去。举例来说：如果SSD能承载的每秒随机IO数是600，但是这个参数设置的是300，那flush缓存页到磁盘的时候，每秒最多就稚嫩执行300次随机IO，根本没有发挥出SSD的性能。还有另外一个重要的参数：<code>innodb_flush_neighbors</code>，这个参数用于说明，在flush缓存页到磁盘的时候可能会把缓存页附近的其他缓存页也刷到磁盘，但是这样有时候会导致flush的缓存页太多了。实际上如果用的是SSD，并没有炳耀设置这个参数，设置成0就好了。</p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="headerlink" title="磁盘数据页的存储结构"></a>磁盘数据页的存储结构</h3><p>磁盘上大量的数据页是按顺序一页一页存放的，两两相邻的数据页之间会采用双向链表的方式互相引用，看起来如下：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714140446086.png" alt="image-20210714140446086" style="zoom:50%;">

<p>一个数据页在磁盘上存储的样子可以<strong>大致</strong>是这样（当然了，这是解码之后又人为臆想的，并不完全是真实如此的）：</p>
<blockquote>
<p>DataPage: xx=xx, xx=xx, linked_list_pre_pointer=15367, linked_list_next_pointer=34126 || DataPage: xx=xx, xx=xx, linked_list_pre_pointer=23789, linked_list_next_pointer=46589 || DataPage: xx=xx, xx=xx, linked_list_pre_pointer=33198, linked_list_next_pointer=55681</p>
</blockquote>
<p>可以看见每个数据页都有两个指针，分别指向上一个数据页在磁盘文件中的起始物理位置和下一个数据页在磁盘文件中的起始物理地址。</p>
<p>然后一个数据页内部会存储一行行的数据，数据页里边的每一行数据都会按照主键的大小进行排序存储，通知每一行数据都有指向下一行数据位置的指针，组成了单项链表。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714151950726.png" alt="image-20210714151950726" style="zoom:50%;">



<p>每个数据页都会有一个页目录，页目录中存放的是主键和槽位的映射关系。数据行是被分散的存储到不同的槽位中去的，每个槽位中存放了多条数据，如下图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714152632491.png" alt="image-20210714152632491" style="zoom:50%;">



<h3 id="无索引的搜索数据搜索"><a href="#无索引的搜索数据搜索" class="headerlink" title="无索引的搜索数据搜索"></a>无索引的搜索数据搜索</h3><p>假设，现在要根据主键查找一条数据，而且此时数据库表中也没有几条数据，表中<strong>一共就一个数据页</strong>，那么就会先到页目录中根据主键进行二分查找迅速定位到数据在哪个槽位中，然后再到槽位中遍历每一行数据，很快就能找到该主键对应的数据了。要是非主键的查找，尴尬，只能进到数据页中，根据单向链表遍历查找了。</p>
<p>如果是多个数据页，无论是否根据主键去查，都无法取巧。只能根据页与页之间的链表关系，以及页中的数据行之间的链表关系，如果是主键查询可以用二分查找，非主键就只能遍历了。这个过程，就是臭名昭著的<strong>全表扫描</strong>。就是根据双向链表，一次吧磁盘上的数据页加载到缓存中去，然后在一个缓存页内部来查找那条数据。</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>在表中不停的插入数据的时候，会有一个页分裂的过程。数据在不停地插入的过程中，一个数据页是肯定是无法容纳所有的数据的，此时就必须搞出来一个新的数据页来容纳新的数据。但是，MySQL有一个规则，<strong>新数据页中的主键的值必须比旧数据页中的主键值都小</strong>。如果表的主键是自增长的，那这个天然就能满足MySQL的规则；如果不是自增长的就涉及到了<strong>页分裂</strong>。这个所谓的页分裂其实就是在新数据页出现的时候，让数据的主键维持上述规则，具体如何做这里不细究，只需要知道无论主键是否是自增长的，。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210714161818252.png" alt="image-20210714161818252" style="zoom:50%;">



<h3 id="主键目录"><a href="#主键目录" class="headerlink" title="主键目录"></a>主键目录</h3><p>前提：有多个数据页，然后根据主键进行查询。</p>
<p>问题：主键在哪个数据页中？不知道主键在哪个数据页中，那还是要走全局扫描啊。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716073321488.png" alt="image-20210716073321488" style="zoom:50%;">

<p>因此，出现了主键目录这个概念：<strong>针对主键设计的目录</strong>。目录中存放的是每个数据页的页号和每个数据页中的最小主键的值的映射关系，如图所示：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716073616519.png" alt="image-20210716073616519" style="zoom:50%;">

<p>此时，问题得以完美解决，可以用主键索引到主键目录中去进行二分查找，最终就可以得到想要的数据所在的页号了，然后到所在的页中进行二分查找即可。</p>
<h3 id="索引的存储结构——B-Tree"><a href="#索引的存储结构——B-Tree" class="headerlink" title="索引的存储结构——B+Tree"></a>索引的存储结构——B+Tree</h3><p>当表中数据非常多，几百万、几千万甚至上亿，磁盘上会有大量的数据页，因此主键目录中的数据页号和数据页中的最小主键的映射关系也会非常的多，此时基于主键进行查找的话，效率会明显降低，那么要如何解决这个问题呢？</p>
<p>实际上，索引也是存放在页中的，索引所在的页叫做<strong>索引页</strong>，数据页特别多的时候也会产生很多的索引页，如图所示。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716075116765.png" alt="image-20210716075116765" style="zoom:50%;">

<p>那么此时问题又来了，根据主键查询的时候，<strong>如何能够知道主键所在的索引页呢</strong>？解决方案其实已经有了，刚刚的上一小节已经说过，数据页比较多的时候，我们整出来了一个数据页的索引页来帮助判定数据所在的数据页，那么同理，索引页比较多的时候，我们可以整出来一个索引页的索引页，来帮助判定索引所在的索引页。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716075654553.png" alt="image-20210716075654553" style="zoom:50%;">

<p>问题又来了，如果索引页的索引页又比较多了怎么办？老办法，再搞出一个索引页的索引页的索引页，一个思想进行到底，如图所示。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210716080442908.png" alt="image-20210716080442908" style="zoom:50%;">

<p>此时，索引的多层级关系已经能够很明显的看出来了，这个层级分明的结构就是我们经常所提及的B+Tree。</p>
<p>当主键索引建立起来之后，其实这个主键索引的结构就是一颗B+Tree，根据主键查询数据的时候，直接从B+Tree的顶层开始二分查找，一层层向下定位，最终定位到了一个数据页中，然后在数据页内部的页目录中进行二分查找就可以很快的找到主键所对应的那条数据。</p>
<p>总结：</p>
<ul>
<li>索引数据存储在于数据页一样的索引页中。</li>
<li>一个索引就是很多索引页组成的一颗B+Tree。</li>
</ul>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>如果一颗大的B+Tree索引数据结构里，叶子节点就是数据页自己本身，那么此时既可以称这颗B+Tree为聚簇索引。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717115058109.png" alt="image-20210717115058109" style="zoom:50%;">

<p>聚簇索引里就包含了数据，数据存放于聚簇索引的叶子节点。聚簇索引是按照主键来组织的。InnoDB会基于主键默认给我们建立聚簇索引。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>假设要根据主键之外的字段——name字段来建立索引，那么InnoDB会再重新建立一颗B+Tree，但是<strong>数据页里仅仅放主键字段和name字段</strong>，其他的跟聚簇索引都一样。之所以存放主键，是为了如果查询语句中还需要查询除了name之外其他字段的时候，可以现在name索引的这颗B+Tree上先查询，查询到数据之后，再用主键再到聚簇索引中进行<strong>回表</strong>查询其他需要的字段。</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717121109605.png" alt="image-20210717121109605" style="zoom:50%;">

<p>也可以把多个字段联合起来建立<strong>联合索引</strong>，比如 name + age。此时联合索引的运行原理也是一样的，只不过是建立一颗独立的B+Tree，然后叶子节点中存放的是id + name + age，默认按照name排序，name一样就按照age排序。</p>
<h3 id="联合索引的使用规则"><a href="#联合索引的使用规则" class="headerlink" title="联合索引的使用规则"></a>联合索引的使用规则</h3><p>假设有一张表，用来存储学生成绩，主键id是自增的，默认会根据他建立聚簇索引，这个不用多说。然后，包含了：</p>
<ul>
<li>学生班级</li>
<li>学生姓名</li>
<li>科目名称</li>
<li>成绩</li>
</ul>
<p>四个字段。</p>
<p>此时，我们给可以针对学生班级、学生姓名、科目名称建立一个联合索引。索引组成的B+Tree如下图：</p>
<img src="/techSnapshot.github.io/2021/07/22/MySQL%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/image-20210717124543448.png" alt="image-20210717124543448" style="zoom:50%;">

<p>接下来，根据这个场景，来简单介绍下联合索引的几个使用规则，也就说，如果满足了这些规则，那么我们的SQL就是能够使用联合索引进行查询的，反之则不能。</p>
<h4 id="等值匹配规则"><a href="#等值匹配规则" class="headerlink" title="等值匹配规则"></a>等值匹配规则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name<span class="operator">=</span><span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> student_name<span class="operator">=</span><span class="string">&#x27;张小强&#x27;</span> <span class="keyword">and</span> subject_name<span class="operator">=</span><span class="string">&#x27;数学&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，where条件里的几个字段有几个值得注意的点：</p>
<ul>
<li>都是基于等值来查询，都是用的等号</li>
<li>字段的名称和顺序跟联合索引一模一样</li>
</ul>
<p>这个就是<strong>等值匹配规则</strong>。即使字段顺序和联合索引不一样，也没关系，MySQL会自动优化为按联合索引的字段顺序去找。</p>
<h4 id="最左侧列匹配原则"><a href="#最左侧列匹配原则" class="headerlink" title="最左侧列匹配原则"></a>最左侧列匹配原则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="operator">=</span> &quot;&quot; <span class="keyword">and</span> studnt_name <span class="operator">=</span> &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这个时候，只要根据联合索引中最左侧的部分字段进行查询就可以，这个SQL是可以用的上联合索引的。</p>
<h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>如果我们写了这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;1%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个sql也是可以用上索引的。</p>
<p>但是如果把SQL写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;%班&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就用不上索引了。</p>
<h4 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h4><p>如果where条件中如果有范围查询，那只有对联合索引里最左侧的列进行范围查询才能用到索引。例如有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">where</span> class_name <span class="operator">&gt;</span> <span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> class_name <span class="operator">&lt;</span> <span class="string">&#x27;5班&#x27;</span> <span class="keyword">and</span> student_name <span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这条语句中，只有class_name是可以基于索引来做查询的，student_name的范围查询是没法用到索引的。</p>
<h4 id="等值匹配-范围匹配"><a href="#等值匹配-范围匹配" class="headerlink" title="等值匹配 + 范围匹配"></a>等值匹配 + 范围匹配</h4><p>假设有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score whre class_name <span class="operator">=</span> <span class="string">&#x27;1班&#x27;</span> <span class="keyword">and</span> student_name<span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> subject_name <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据等值匹配规则，class_name可以用得上索引，先根据class_name = ‘1班’筛选出来一波数据，筛选出来的数据中的student_name必然都是排好序的，所以student_name&gt; ‘’也是可以用得上索引的，但是接下来的subject_name &lt; ‘’是不能用索引的。</p>
<h4 id="order-by的索引使用规则"><a href="#order-by的索引使用规则" class="headerlink" title="order by的索引使用规则"></a>order by的索引使用规则</h4><p>最好根据联合索引的顺序写order by语句，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">order</span> <span class="keyword">by</span> class_name , student_name , subject_name</span><br></pre></td></tr></table></figure>



<h4 id="group-by的索引使用规则"><a href="#group-by的索引使用规则" class="headerlink" title="group by的索引使用规则"></a>group by的索引使用规则</h4><p>最好根据联合索引的顺序写order by语句，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_score <span class="keyword">group</span> <span class="keyword">by</span> class_name , student_name , subject_name</span><br></pre></td></tr></table></figure>



<h3 id="覆盖索引是什么"><a href="#覆盖索引是什么" class="headerlink" title="覆盖索引是什么"></a>覆盖索引是什么</h3><p>覆盖索引其实不是一种索引，他就是一种基于索引查询的方式罢了。</p>
<p>他的意思就是，我仅仅需要查询联合索引里的几个字段的值，那么其实就只要扫描联合索引的索引树就可以了，不需要回表去聚簇索引里找其他字段了。</p>
<p>因此，在写SQL的时候：</p>
<ul>
<li>尽量的不要写select * ，避免回表，最好是能走覆盖索引。</li>
<li>就算是真的要回表，也尽可能用limit、where这样的语句限定下回表的次数。</li>
</ul>
<h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><h4 id="索引设计的步骤"><a href="#索引设计的步骤" class="headerlink" title="索引设计的步骤"></a>索引设计的步骤</h4><ol>
<li>表结构设计完毕后，不要着急设计索引，因为此时根本不知道该怎么查询表</li>
<li>当系统差不多开发完毕了，功能都跑通了，就能完全知道如何对一张表发起一些什么样的SQL语句</li>
<li>针对SQL语句里边的where条件、order by语句以及group by条件去设计索引</li>
<li>可以设计一个或者两三个联合索引，每一个联合索引都尽量去包含where、order by、group by里的字段</li>
<li>审查每个SQL语句，是否都满足最左侧列原则</li>
</ol>
<h4 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h4><ul>
<li>（比较重要）尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能<strong>发挥出B+Tree快速二分查找的优势</strong></li>
<li>尽量针对那些字段的类型比较小的列来设计索引，比如tinyint之类的，这样会让索引树占用的磁盘空间更小，查询效率更高</li>
<li>如果索引字段比较大，比如varchar(255)，可以考虑一下，仅仅针对这个varchar(255)字段的前20个字符建立索引。当然，ordre by 跟 group by是用不上这样的索引的。where可以用上，但是在查询语句中的查询字段中要查询这个索引字段的时候，就需要回表了</li>
<li>（比较重要）如果给索引字段搞了个函数或者搞了个计算，那么此时是无法使用索引的</li>
<li>索引别设计太多，因为插入的数据的值可能不是按照顺序来的，很可能导致索引树里边的某个页会自动分裂，这个分裂的过程很耗费时间，<strong>一般两三个联合索引就应该覆盖掉这个表的全部查询了</strong></li>
<li>建议主键要是自增的，别用UUID之类的，因为主键自增的话，起码聚簇索引不会频繁的分裂，只会自然的新增一个页</li>
</ul>
<h4 id="实战场景下的索引设计技巧"><a href="#实战场景下的索引设计技巧" class="headerlink" title="实战场景下的索引设计技巧"></a>实战场景下的索引设计技巧</h4><ul>
<li><p>在有些SQL中，where和order by实际上大部分情况下是没法都用到索引的，鱼和熊掌不可兼得。一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据接着再进行排序，最后针对排序后的数据拿出来一页数据</p>
</li>
<li><p>基数较低的字段<strong>但是频繁查询</strong>的字段也可以放到联合索引的最左侧去</p>
</li>
<li><p>经常用于范围查询的字段，一定要放在联合索引的最后</p>
</li>
<li><p>针对一些<strong>频繁使用的包含枚举值范围的一些字段，也完全可以加入到联合索引里去</strong>，可以设计成（province, city, sex, hobby, character, age）这样的一个联合索引，此时假设出现了这样一个查询，按照省份、城市、性格和年龄进行搜索，此时SQL怎么写？就是写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> province<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx <span class="keyword">and</span> sex <span class="keyword">in</span>(xx, xx) <span class="keyword">and</span> hobby <span class="keyword">in</span> (xx, xx, xx, xx) <span class="keyword">and</span> <span class="type">character</span><span class="operator">=</span>xx <span class="keyword">and</span> age<span class="operator">&gt;=</span>xx <span class="keyword">and</span> age<span class="operator">&lt;=</span>xx</span><br></pre></td></tr></table></figure>

<p>也就是说，即使你不需要按性别和爱好进行筛选，但是在SQL里你可以对这两个字段用in语句，把他们所有的枚举值都放进去</p>
</li>
<li><p>可以针对那些基数很低的字段，在家还是那个排序字段单独额外设计一个<strong>辅助索引</strong>，专门用于解决<strong>where条件中都是基数低的字段，然后还需要排序后分页的问题</strong></p>
</li>
<li><p>尽量利用一两个复杂的多字段联合索引，抗下80%以上的查询，然后用一两个辅助索引抗下神域的20%的非典型查询，保证99%以上的查询都能充分利用索引，这样就能保证系统整体的查询速度和性能</p>
</li>
</ul>
<h2 id="SQL语句执行计划"><a href="#SQL语句执行计划" class="headerlink" title="SQL语句执行计划"></a>SQL语句执行计划</h2><h4 id="查询级别"><a href="#查询级别" class="headerlink" title="查询级别"></a>查询级别</h4><table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>const</td>
<td>性能排名第一；主键索引或者二级索引是unique key唯一索引进行的查询</td>
</tr>
<tr>
<td>ref</td>
<td>性能排名第二；二级索引是包含多个列的普通索引；查询语句需要满足最左侧列原则，然后必须都是等值比较</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>ref的一个特例；针对一个二级索引，比较了值还限定了IS NULL</td>
</tr>
<tr>
<td>range</td>
<td>性能排名第三；查询语句中有范围查询</td>
</tr>
<tr>
<td>index</td>
<td>性能排名第四；举例：假设表的联合索引是（x1,x2,x3），现在写一个SQL语句：select x1,x2,x3 from table where x2 = xxx，查询的字段刚好是联合索引中的字段，此时MySQL会直接遍历二级索引的叶结点，然后找到x2=xxx的那些数据，然后把x1,x2,x3的值提出来就ok了</td>
</tr>
<tr>
<td>all</td>
<td>性能最差；尽最大可能避免这种查询级别的发生</td>
</tr>
</tbody></table>
<h3 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h3><p>假设有如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.x1<span class="operator">=</span>xxx <span class="keyword">and</span> t1.x2 <span class="operator">=</span> t2.x2 <span class="keyword">and</span> t2.x3 <span class="operator">=</span> xxx	</span><br></pre></td></tr></table></figure>

<p>MySQL会先根据t1.x1=xxx这个条件筛选，去t1表里去查出来一批数据，假设筛选出来了10条数据。然后用被筛选出来的这10条数据的x2的字段的值，依次到t2表中去匹配数据，匹配完后关联起来即可。</p>
<p>记住：<strong>先从一个表中查一波数据，这个表叫做“驱动表”（可能就是我们平时总说的主表），再根据这波数据区另外一个表里查一波数据，然后进行关联，另外这个表就叫做“被驱动表”。</strong></p>
<p>上述的多表关联的SQL的执行原理有一个名词可以对其进行描述：<strong>嵌套循环关联</strong>。嵌套循环关联在索引没有设计好的时候，会产生一些性能问题：</p>
<ul>
<li>首先，从驱动表中筛选第一波数据的时候，如果没有用上索引，会走全表扫描</li>
<li>其次，从驱动表中筛选出来第一波数据之后（假设筛选出了100条），会循环这些数据，然后到被驱动表中去查，此时如果驱动表又没加索引，又得在被驱动表中走个100次全表扫描</li>
<li>再其次，如果需要关联更多的表，对性能的影响就更是雪上加霜</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">JVM-Class文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 22:54:24" itemprop="dateCreated datePublished" datetime="2021-01-14T22:54:24+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-18 23:07:38" itemprop="dateModified" datetime="2021-01-18T23:07:38+08:00">2021-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114213638161.png" alt="image-20210114213638161" style="zoom:80%;">



<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Class文件采用一种类似于C语言的结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。</p>
<p><strong>无符号数</strong></p>
<p>基本的数据类型，以u1,u2,u4,u8来分别代表1、2、4、8个字节的无符号数。无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</p>
<p><strong>表</strong></p>
<p>由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的用<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由下表所示的数据项构成。</p>
<p>![Screen Shot 2019-05-31 at 9.45.25 AM](JVM-Class文件/Screen Shot 2019-05-31 at 9.45.25 AM.png)</p>
<h3 id="魔数和class文件版本信息"><a href="#魔数和class文件版本信息" class="headerlink" title="魔数和class文件版本信息"></a>魔数和class文件版本信息</h3><p>魔术用来标识是否是一个Class文件，Class文件的魔数用16进制标识是<code>CAFEBABE</code>。</p>
<p>版本信息分为次版本和主版本，主版本号从<code>45</code>开始，对应JDK1.1。</p>
<p>JDK1.1 &lt;——&gt; 45</p>
<p>JDK<strong>向下兼容</strong>旧版本的Class文件。例如，Class文件的major_version（主版本号）为0x34（52），则支持的JDK为，1 + (52 -45) = 8，也就是1.8以及1.8以上版本的JDK都可以执行这个Class文件。</p>
<blockquote>
<p>可见<strong>JVM是要和Class文件相兼容的</strong>。如果Class的主版本号过高导致JDK无法兼容，则会抛出“<em>java.lang.UnsupportedClassVersionError: Bad version number in .class file</em>”异常。</p>
</blockquote>
<p>另外，可以采用<code>javap -v $&#123;ClassFileName&#125; </code>来查看Class文件的版本号。</p>
<h3 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h3><p>首先要知道，常量池是由一组 <code>cp_info</code>结构体数组组成，暂且把这个数组叫做A。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114214609620.png" alt="image-20210114214609620" style="zoom:50%;">

<p>常量池计数器的作用主要是为常量池计数。他的数量是常量池中的常量的数量的值加一。例如，常量池中的常量的数量为100，那么这个计数器的值为101。<code>constant_pool</code>表的<strong>索引值</strong>只有在大于 0 且小于<code>constant_pool_count</code>时才会被认为是有效的。</p>
<blockquote>
<p>也就是说，常量池计数器的计数=A的长度。</p>
</blockquote>
<p>A的0号索引处的值被空出，当某些数据在特定的情况下想表达“<strong>不引用任何一个常量池项</strong>”的意思时，就可以将其引用的常量的索引值设置为0来表示。这也是常量池计数器大于等于一的原因。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>上边说到的<code>constant_pool</code>，其中表示的是一个<code>cp_info</code>数组，<code>cp_info</code>表示的是<strong>常量池项</strong>，下图表示的是其结构。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114215706024.png" alt="image-20210114215706024" style="zoom:50%;">





<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>用于表示某个类或者接口的<strong>访问权限</strong>及<strong>基础属性</strong>。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114220816073.png" alt="image-20210114220816073" style="zoom:50%;">

<p>表示这个 Class 文件所定义的类或接 口。</p>
<h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p><code>this_class</code>的值必须是constant_pool表的一个有效索引，索引处的类型为<code>Constant_Class_info</code>，表示这个 Class 文件所定义的类或接 口。</p>
<h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>父类索引，对于类来说，<code>super_class</code> 的值必须为 0 或者是对constant_pool 表中项目的一个有 效索引值。</p>
<p>如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为Constant_Class_info类型常 量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的 <code>access_flag</code> 中都不能带有<code>ACC_FINAL</code> 标记。对于接口来说，它的Class文件的super_class项的 值必须是对constant_pool表中项目的一个有效索引值，这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p>
<p>如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是 java.lang.Object类，只有它是唯一没有父类的类。</p>
<h3 id="接口计数器"><a href="#接口计数器" class="headerlink" title="接口计数器"></a>接口计数器</h3><p>接口计数器，interfaces_count的值表示当前类或接口的【直接父接口数量】。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口计数器的值为2。</p>
<h3 id="接口信息数据区"><a href="#接口信息数据区" class="headerlink" title="接口信息数据区"></a>接口信息数据区</h3><p><code>interfaces</code>每个成员的值必须是一个constant_pool的一个有效索引值，索引处所对应的值必须为 Constant_Class_info类型常量。interfaces的长度为 interfaces_count。在interfaces中，成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即interfaces[0]对 应的是源代码中最左边的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interfaces[0] 处的值引用constant_pool中的某个Constant_Class_info类型的常量，表示的是InterfaceA</p>
<p>interfaces[1] 处的值引用constant_pool中的某个Constant_Class_info类型的常量，表示的是InterfaceB</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210114223641114.png" alt="image-20210114223641114" style="zoom:50%;">

<h3 id="字段计数器"><a href="#字段计数器" class="headerlink" title="字段计数器"></a>字段计数器</h3><p><code>fields_count</code>的值表示当前 Class 文件 fields的成员个数。 fields 中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String str0;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段计数器的值 = 2。</p>
<h3 id="字段信息数据区"><a href="#字段信息数据区" class="headerlink" title="字段信息数据区"></a>字段信息数据区</h3><p><code>fields</code>中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接 口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接 口继承的部分。</p>
<h3 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h3><p><code>methods_count</code>的值表示当前Class 文件 methods的成员个数。methods中每一项都是一个 method_info 结构的数据项。</p>
<h3 id="方法信息数据区"><a href="#方法信息数据区" class="headerlink" title="方法信息数据区"></a>方法信息数据区</h3><p><code>methods</code>中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。</p>
<p>如果某个method_info 结构的<code>access_flags</code>项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需 要引用其它类。</p>
<p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类 或接口初始化方法 。</p>
<blockquote>
<p>methods只描述当前类或接口中声明的方法，<strong>不包括从父类或父接口继承的方法</strong>。</p>
</blockquote>
<h3 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h3><p><code>attributes_count</code>的值表示当前 Class 文件attributes表的成员个数。 attributes表中每一项都是一个attribute_info 结构的数据项。</p>
<h3 id="属性信息数据区"><a href="#属性信息数据区" class="headerlink" title="属性信息数据区"></a>属性信息数据区</h3><p><code>attributes</code> 表的每个项的值必须是attribute_info结构。</p>
<p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性: </p>
<ul>
<li>InnerClasses </li>
<li>EnclosingMethod </li>
<li>Synthetic </li>
<li>Signature</li>
<li>SourceFile</li>
<li>SourceDebugExtension </li>
<li>Deprecated</li>
<li>RuntimeVisibleAnnotations </li>
<li>RuntimeInvisibleAnnotations</li>
<li>BootstrapMethods</li>
</ul>
<blockquote>
<p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的Signature、RuntimeVisibleAnnotations和 RuntimeInvisibleAnnotations属性。</p>
<p>对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。</p>
<p>Java 7 规范 要求 任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 (甚至全部) 它不可 识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息。</p>
</blockquote>
<h2 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h2><h3 id="常量池项的结构"><a href="#常量池项的结构" class="headerlink" title="常量池项的结构"></a>常量池项的结构</h3><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117195054266.png" alt="image-20210117195054266" style="zoom:50%;">



<h3 id="常量池项的结构-1"><a href="#常量池项的结构-1" class="headerlink" title="常量池项的结构"></a>常量池项的结构</h3><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117203550208.png" alt="image-20210117203550208" style="zoom:50%;">

<blockquote>
<p>cp_info会记录class文件中某种类型的字面量。JVM根据tag值确定cp_info表示什么类型的字面量</p>
</blockquote>
<p>tag有多种取值，<strong>不同tag值表示的不同结构</strong>。</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210117203849652.png" alt="image-20210117203849652" style="zoom:50%;">

<p>细化后的常量池结构</p>
<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220250754.png" alt="image-20210118220250754" style="zoom:50%;">





<h3 id="不同类型的常量池项的存储方式"><a href="#不同类型的常量池项的存储方式" class="headerlink" title="不同类型的常量池项的存储方式"></a>不同类型的常量池项的存储方式</h3><h4 id="int和float类型"><a href="#int和float类型" class="headerlink" title="int和float类型"></a>int和float类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220315591.png" alt="image-20210118220315591" style="zoom:50%;">

<p><code>CONSTANT_Integer_info</code>和<code>CONSTANT_Float_info</code>直接用四个字节进行数据的存储。</p>
<h4 id="long和double类型"><a href="#long和double类型" class="headerlink" title="long和double类型"></a>long和double类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118220811792.png" alt="image-20210118220811792" style="zoom:50%;">

<p><code>CONSTANT_Long_info</code>和<code>CONSTANT_Double_info</code>直接用两个u4进行存储。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221207663.png" alt="image-20210118221207663" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221234164.png" alt="image-20210118221234164" style="zoom:50%;">

<p>由上两图可以看出，String类型相较于前两种类型的存储方式的不同之处在于：它并没有直接在<code>CONSTANT_String_info</code>中直接存储字符串的数据。它先用<code>CONSTANT_String_info</code>这种高级结构中的<code>tag</code>指定了cp_info的结构是String，然后用一个两字节的<code>string_index</code>存储了一个指向<code>CONSTANT_Utf8_info</code>结构的指针，在<code>CONSTANT_Utf8_info</code>中存储的了真正的字符串数据。</p>
<blockquote>
<p>问题：</p>
<p>为什么不在CONSTANT_String_info中，直接存储字符串数据呢？</p>
</blockquote>
<h4 id="类文件中定义的类名和类中使用到的类"><a href="#类文件中定义的类名和类中使用到的类" class="headerlink" title="类文件中定义的类名和类中使用到的类"></a>类文件中定义的类名和类中使用到的类</h4><img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118222511003.png" alt="image-20210118222511003" style="zoom:50%;">

<img src="/techSnapshot.github.io/2021/01/14/JVM-Class%E6%96%87%E4%BB%B6/image-20210118221234164.png" alt="image-20210118221234164" style="zoom:50%;">

<p>与字符串的存储结构几乎相同。</p>
<h3 id="哪些字面量会被存储进常量池"><a href="#哪些字面量会被存储进常量池" class="headerlink" title="哪些字面量会被存储进常量池"></a>哪些字面量会被存储进常量池</h3><ol>
<li>final类型的8种<strong>基本类型</strong>的值会进入常量池。</li>
<li>非final类型(包括static的)的8种基本类型的值，只有<code>double</code>、<code>float</code>、<code>long</code>的值会进入常量 池。</li>
<li>字符串类型字面量(<strong>双引号</strong>引起来的字符串值)。</li>
</ol>
<h2 id="Class文件中的引用和特殊字符串"><a href="#Class文件中的引用和特殊字符串" class="headerlink" title="Class文件中的引用和特殊字符串"></a>Class文件中的引用和特殊字符串</h2><h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><p><strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，使用时能够正确的定义到目标即可。</strong></p>
<p>Java源代码会被编译为Class文件，在<strong>编译期</strong>可能无法得知当前类引用的累的地址，因此使用符号引用进行代替。符号引用在Class文件中的结构有以下几种：</p>
<ul>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Fieldref_info</li>
<li>CONSTANT_Methodref_info</li>
</ul>
<blockquote>
<p>猜想</p>
<p><code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>这两种结构应该跟<code>CONSTANT_Class_info</code>的存储方式是一致的。</p>
</blockquote>
<p>符号引用与虚拟机的内存布局无关，引用的目标不一定会被加载到内存当中。</p>
<h3 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h3><p>直接引用可以是：</p>
<ul>
<li>直接指向目标的指针（如：指向类方法的直接引用可能是指向方法区的指针）。</li>
<li>相对偏移量</li>
<li>一个能间接定义到目标的句柄</li>
</ul>
<p>直接引用与虚拟机的内存布局相关，上边所说的符号引用会被替换成直接引用，同一个符号引用在不同的虚拟机上被替换成的直接引用一般不会相同。<strong>如果有了直接引用，那么所引用的对象一定是已经被加载到内存当中了</strong>。</p>
<h3 id="符号引用替换成直接引用"><a href="#符号引用替换成直接引用" class="headerlink" title="符号引用替换成直接引用"></a>符号引用替换成直接引用</h3><h4 id="替换时机"><a href="#替换时机" class="headerlink" title="替换时机"></a>替换时机</h4><p>类的加载过程分为：</p>
<ol>
<li>加载</li>
<li>连接<ol>
<li>验证</li>
<li>准备</li>
<li>解析  *</li>
</ol>
</li>
</ol>
<p>解析阶段符号引用会被替换为直接引用。</p>
<h3 id="特殊字符串"><a href="#特殊字符串" class="headerlink" title="特殊字符串"></a>特殊字符串</h3><h5 id="类的完全限定名"><a href="#类的完全限定名" class="headerlink" title="类的完全限定名"></a>类的完全限定名</h5><h5 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h5><h6 id="各数据类型的描述符"><a href="#各数据类型的描述符" class="headerlink" title="各数据类型的描述符"></a>各数据类型的描述符</h6><h6 id="字段描述符"><a href="#字段描述符" class="headerlink" title="字段描述符"></a>字段描述符</h6><h6 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h6><h5 id="特殊方法的方法名"><a href="#特殊方法的方法名" class="headerlink" title="特殊方法的方法名"></a>特殊方法的方法名</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/13/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/13/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 20:25:45" itemprop="dateCreated datePublished" datetime="2021-01-13T20:25:45+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-22 15:20:12" itemprop="dateModified" datetime="2021-07-22T15:20:12+08:00">2021-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><p>操作系统太重了<img src="/techSnapshot.github.io/2021/01/13/Docker/v2-c20cb49c88034e73e09059668b8cecfb_1440w.jpg" alt="v2-c20cb49c88034e73e09059668b8cecfb_1440w" style="zoom:50%;"></p>
<p>操作系统重启是非常慢的</p>
<p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong></p>
<h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个：</p>
<ul>
<li>轻量级的</li>
<li>可移植的</li>
<li>自给自足的</li>
</ul>
<p>容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p>
<p>容器是一种通用技术，docker只是其中的一种实现。</p>
<h2 id="Docker拥有哪些能力？"><a href="#Docker拥有哪些能力？" class="headerlink" title="Docker拥有哪些能力？"></a>Docker拥有哪些能力？</h2><p>Docker提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。这样你的程序可以在任何环境都会有一致的表现，因此docker最重要的能力就是：<strong>可以屏蔽环境差异</strong>。</p>
<p>由于Docker具有屏蔽环境的差异的能力，由此衍生出了另外一个重要的应用能力：<strong>快速部署</strong>。只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。真正实现<strong>“build once, run everywhere”</strong>。</p>
<h2 id="我能用Docker干啥？"><a href="#我能用Docker干啥？" class="headerlink" title="我能用Docker干啥？"></a>我能用Docker干啥？</h2><ul>
<li>快速、一致的交付你的应用程序</li>
<li>响应式发布和扩展</li>
<li>在相同的硬件上能够运行更多的工作负载</li>
</ul>
<p>​    </p>
<h2 id="Docker引擎介绍"><a href="#Docker引擎介绍" class="headerlink" title="Docker引擎介绍"></a>Docker引擎介绍</h2><p>docker客户端</p>
<ul>
<li>SERVER（docker daemon）</li>
<li>REST API</li>
<li>CLI</li>
</ul>
<img src="/techSnapshot.github.io/2021/01/13/Docker/engine-components-flow.png" alt="engine-components-flow" style="zoom:80%;">

<blockquote>
<p>docker客户端和服务端一般运行在同一台机器上</p>
</blockquote>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><img src="/techSnapshot.github.io/2021/01/13/Docker/architecture.svg" alt="architecture" style="zoom:80%;">

<ul>
<li><p>The <strong>Docker daemon (</strong><code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p>
</li>
<li><p>The <strong>Docker client</strong> (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p>
</li>
<li><p>A <strong>Docker <em>registry</em></strong> stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.</p>
<p>When you use the <code>docker pull</code> or <code>docker run</code> commands, the required images are pulled from your configured registry. When you use the <code>docker push</code> command, your image is pushed to your configured registry.</p>
</li>
</ul>
<h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><p>docker中有这样几个概念：</p>
<ul>
<li>dockerfile：源程序</li>
<li>image：可执行程序</li>
<li>container：进程</li>
</ul>
<p>实际上你可以简单的把image理解为可执行程序，container就是运行起来的进程。</p>
<p>那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是”编译器”。</p>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
<h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>CentOS7</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker	</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CentOS7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/etc/docker/daemon.json</span></span><br><span class="line">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span><br></pre></td></tr></table></figure>



<h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有运行中的容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有容器，包括所有状态</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看最后一次创建的容器</span></span><br><span class="line">docker ps -l </span><br></pre></td></tr></table></figure>

<p>容器状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<h4 id="启停容器"><a href="#启停容器" class="headerlink" title="启停容器"></a>启停容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/<span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span>，然后输出结果。</span></span><br><span class="line">docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t: 在新容器内指定一个伪终端或终端。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</span></span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d：后台启动</span></span><br><span class="line">docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动已经停止的容器</span></span><br><span class="line">docker start &lt;容器Id&gt;</span><br><span class="line">docker restart &lt;容器Id&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">docker stop &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>

<p><strong>为什么Docker刚运行完run命令就停止了？</strong></p>
<blockquote>
<p>Docker 容器启动后，默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器是否正在运行的依据。<br>如果docker 容器pid=1进程挂了，那么docker容器便会直接退出。这样的话，如果我们在前台维持一个运行的进程，docker 容器就会一直处于运行的状态中。</p>
</blockquote>
<h4 id="监控容器"><a href="#监控容器" class="headerlink" title="监控容器"></a>监控容器</h4><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看日志</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1 查看标准输出</span></span><br><span class="line">docker logs &#123;容器ID或者容器名称&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">2 让docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</span></span><br><span class="line">docker logs -f &#123;容器ID或者容器名称&#125;  </span><br></pre></td></tr></table></figure>



<h5 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>



<h5 id="检查Docker"><a href="#检查Docker" class="headerlink" title="检查Docker"></a>检查Docker</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器Id&gt;</span><br></pre></td></tr></table></figure>



<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这种方式进入容器，<span class="built_in">exit</span>的时候，会将容器停止，不推荐使用</span></span><br><span class="line">docker attach &lt;容器Id&gt; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果从这个容器退出，容器不会停止，这就是为什么推荐使用 docker <span class="built_in">exec</span> 的原因</span></span><br><span class="line">docker exec -it &lt;容器Id&gt; /bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导出容器</span></span><br><span class="line">docker export &lt;容器Id&gt; &gt; ubuntu.tar</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">导入容器1</span></span><br><span class="line">cat docker/ubuntu.tar | docker import - test/ubuntu:v1</span><br><span class="line"><span class="meta">#</span><span class="bash">导入容器2</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>



<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除某个容器</span></span><br><span class="line">docker rm -f &lt;容器Id&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除所有处于终止状态的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure>



<h3 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h3><p>####列出所有镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<h4 id="运行某个镜像"><a href="#运行某个镜像" class="headerlink" title="运行某个镜像"></a>运行某个镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行某个镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t: 在新容器内指定一个伪终端或终端。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</span></span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d 在后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-P 与主机的高端口绑定</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--name 指定容器名称</span></span><br><span class="line">docker run -d -P --name runoob training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<h4 id="获取一个镜像"><a href="#获取一个镜像" class="headerlink" title="获取一个镜像"></a>获取一个镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>



<h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>



<h4 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>



<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure>



<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><h5 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动一个镜像，比如Ubuntu</span></span><br><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">做一些更新操作</span></span><br><span class="line">apt-get update </span><br><span class="line"><span class="meta">#</span><span class="bash">然后提交更新</span></span><br><span class="line">docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; &lt;Docker Id&gt; runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>

<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p><strong>Dockerfile</strong> 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。下边是一个Dockerfile的示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     useradd runoob</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>

<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</p>
<p>然后，使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t runoob/centos:6.7 .</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<h4 id="给镜像添加标签"><a href="#给镜像添加标签" class="headerlink" title="给镜像添加标签"></a>给镜像添加标签</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="number">860</span>c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>



<h3 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h3><h4 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line">docker run -d -p training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<p>也可以绑定主机的Ip地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>



<h5 id="绑定UDP端口"><a href="#绑定UDP端口" class="headerlink" title="绑定UDP端口"></a>绑定UDP端口</h5><p>端口后面加上 <strong>/udp</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure>



<h5 id="查看端口绑定情况"><a href="#查看端口绑定情况" class="headerlink" title="查看端口绑定情况"></a>查看端口绑定情况</h5><p><strong>docker port</strong> 命令可以让我们快捷地查看容器的端口的绑定情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看容器的5000端口是如主机的哪个端口相绑定</span></span><br><span class="line">docker port &lt;容器Id&gt; 5000</span><br></pre></td></tr></table></figure>



<h4 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h4><p>Docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>Docker 连接会创建一个<strong>父子关系</strong>，其中父容器可以看到子容器的信息。</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h5><ol>
<li>先创建一个新的 Docker 网络</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d：参数指定 Docker 网络类型，有 bridge、overlay。</span></span><br><span class="line">docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行一个容器并连接到新建的 test-net 网络，指定容器名称为test1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再运行一个容器并加入到 test-net 网络，指定容器名称为test2</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入容器test1去ping test2</span></span><br><span class="line">docker exec -it test1 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">没有ping命令则需要执行:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt install iputils-ping</span></span><br><span class="line">ping test2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">test2 ping test1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">操作同上</span></span><br></pre></td></tr></table></figure>



<h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><h5 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h5><p>CentOS上，Docker的配置文件在：/etc/docker/daemon.json这个位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完后，重启Docker。</p>
<p>查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm  ubuntu  cat etc/resolv.conf</span><br></pre></td></tr></table></figure>



<h5 id="指定容器配置"><a href="#指定容器配置" class="headerlink" title="指定容器配置"></a>指定容器配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br></pre></td></tr></table></figure>

<p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p>
<p><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p>
<p><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p>
<blockquote>
<p>如果在容器启动时没有指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p>
</blockquote>
<h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><p>仓库（Repository）是集中存放镜像的地方。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker search ubuntu</span><br><span class="line">docker pull ubuntu </span><br><span class="line">docker tag ubuntu:18.04 &lt;username&gt;/ubuntu:18.04</span><br><span class="line">docker push &lt;username&gt;/ubuntu:18.04</span><br><span class="line">docker search &lt;username&gt;/ubuntu</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure>



<h2 id="Docker工具"><a href="#Docker工具" class="headerlink" title="Docker工具"></a>Docker工具</h2><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<h4 id="Compose-三部曲"><a href="#Compose-三部曲" class="headerlink" title="Compose 三部曲"></a>Compose 三部曲</h4><ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">SpringBoot自动配置原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 22:15:40" itemprop="dateCreated datePublished" datetime="2021-01-08T22:15:40+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:06:38" itemprop="dateModified" datetime="2021-03-28T09:06:38+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Spring-Boot应用的启动入口"><a href="#Spring-Boot应用的启动入口" class="headerlink" title="Spring Boot应用的启动入口"></a>Spring Boot应用的启动入口</h4><p><strong>自动配置</strong>充分的利用了spring 4.0的条件化配置特性，那么，Spring Boot是如何实现自动配置的？Spring 4中的条件化配置又是怎么运用到Spring Boot中的呢？这要从Spring Boot的启动类说起。Spring Boot应用通常有一个名为<code>*Application</code>的入口类，入口类中有一个<code>main</code>方法，这个方法其实就是一个标准的Java应用的入口方法。一般在<code>main</code>方法中使用<code>SpringApplication.run()</code>来启动整个应用。值得注意的是，这个入口类要使用<code>@SpringBootApplication</code>注解声明。<code>@SpringBootApplication</code>是Spring Boot的核心注解，他是一个组合注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code>是一个组合注解，它主要包含<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>等几个注解。也就是说可以直接在启动类中使用这些注解来代替<code>@SpringBootApplication</code>注解。 关于Spring Boot中的Spring自动化配置主要是<code>@EnableAutoConfiguration</code>的功劳。该注解可以让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置。</p>
<p>至此，我们知道，Spring Boot的自动化配置主要是通过<code>@EnableAutoConfiguration</code>来实现的，因为我们在程序的启动入口使用了<code>@SpringBootApplication</code>注解，而该注解中组合了<code>@EnableAutoConfiguration</code>注解。所以，在启动类上使用<code>@EnableAutoConfiguration</code>注解，就会开启自动配置。</p>
<p>那么，本着刨根问底的原则，当然要知道<code>@EnableAutoConfiguration</code>又是如何实现自动化配置的，因为目前为止，我们还没有发现Spring 4中条件化配置的影子。</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration"></a>EnableAutoConfiguration</h4><p>其实Spring框架本身也提供了几个名字为<code>@Enable</code>开头的Annotation定义。比如<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code>等，<code>@EnableAutoConfiguration</code>的理念和这些注解其实是一脉相承的。</p>
<blockquote>
<p><code>@EnableScheduling</code>是通过<code>@Import</code>将Spring调度框架相关的bean定义都加载到IoC容器。</p>
<p><code>@EnableMBeanExport</code>是通过<code>@Import</code>将JMX相关的bean定义加载到IoC容器。</p>
<p><code>@EnableAutoConfiguration</code>也是借助<code>@Import</code>的帮助，将所有符合自动配置条件的bean定义加载到IoC容器。</p>
</blockquote>
<p>下面是<code>EnableAutoConfiguration</code>注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>@EnableAutoConfiguration</code>可以发现，这里<strong>Import</strong>了<code>@EnableAutoConfigurationImportSelector</code>，这就是Spring Boot自动化配置的“始作俑者”。</p>
<p>至此，我们知道，由于我们在Spring Boot的启动类上使用了<code>@SpringBootApplication</code>注解，而该注解组合了<code>@EnableAutoConfiguration</code>注解，<code>@EnableAutoConfiguration</code>是自动化配置的“始作俑者”，而<code>@EnableAutoConfiguration</code>中Import了<code>@EnableAutoConfigurationImportSelector</code>注解，该注解的内部实现已经很接近我们要找的“真相”了。</p>
<h4 id="EnableAutoConfigurationImport-Selector"><a href="#EnableAutoConfigurationImport-Selector" class="headerlink" title="EnableAutoConfigurationImport-Selector"></a>EnableAutoConfigurationImport-Selector</h4><p><code>EnableAutoConfigurationImportSelector</code>的源码在这里就不贴了，感兴趣的可以直接去看一下，其实实现也比较简单，主要就是使用Spring4 提供的的<code>SpringFactoriesLoader</code>工具类。通过<code>SpringFactoriesLoader.loadFactoryNames()</code>读取了ClassPath下面的<code>META-INF/spring.factories</code>文件。</p>
<blockquote>
<p>这里要简单提一下<code>spring.factories</code>文件，它是一个典型的java properties文件，配置的格式为<strong>Key = Value</strong>形式。</p>
</blockquote>
<p><code>EnableAutoConfigurationImportSelector</code>通过读取<code>spring.factories</code>中的key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>的值。如<code>spring-boot-autoconfigure-1.5.1.RELEASE.jar</code>中的<code>spring.factories</code>文件包含以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">......</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>上面的<code>EnableAutoConfiguration</code>配置了多个类，这些都是Spring Boot中的自动配置相关类；在启动过程中会解析对应类配置信息。每个<code>Configuation</code>都定义了相关bean的实例化配置。都说明了哪些bean可以被自动配置，什么条件下可以自动配置，并把这些bean实例化出来。</p>
<blockquote>
<p>如果我们新定义了一个starter的话，也要在该starter的jar包中提供 <code>spring.factories</code>文件，并且为其配置<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>对应的配置类。</p>
</blockquote>
<h4 id="Configuation"><a href="#Configuation" class="headerlink" title="Configuation"></a>Configuation</h4><p>我们从<code>spring-boot-autoconfigure-1.5.1.RELEASE.jar</code>中的<code>spring.factories</code>文件随便找一个Configuration，看看他是如何自动加载bean的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;JmxAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.application.admin&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationAdminJmxAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringApplicationAdminMXBeanRegistrar <span class="title">springApplicationAdminRegistrar</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;</span><br><span class="line">        String jmxName = <span class="keyword">this</span>.environment.getProperty(<span class="string">&quot;spring.application.admin.jmx-name&quot;</span>, <span class="string">&quot;org.springframework.boot:type=Admin,name=SpringApplication&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.mbeanExporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mbeanExporter.addExcludedBean(jmxName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationAdminMXBeanRegistrar(jmxName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到上面的代码，终于找到了我们要找的东西——Spring 4的条件化配置。上面<code>SpringApplicationAdminJmxAutoConfiguration</code>在决定对哪些bean进行自动化配置的时候，使用了两个条件注解：<code>ConditionalOnProperty</code>和<code>ConditionalOnMissingBean</code>。只有满足这种条件的时候，对应的bean才会被创建。这样做的好处是什么？这样可以保证某些bean在没满足特定条件的情况下就可以不必初始化，避免在bean初始化过程中由于条件不足，导致应用启动失败。</p>
<p>至此，我们可以总结一下Spring Boot的自动化配置的实现：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/r-20201030105053638.png" alt="img"></p>
<p>通过Spring 4的条件配置决定哪些bean可以被配置，将这些条件定义成具体的<code>Configuation</code>，然后将这些<code>Configuation</code>配置到<code>spring.factories</code>文件中，作为key: <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>的值，这时候，容器在启动的时候，由于使用了EnableAutoConfiguration注解，该注解Import的<code>EnableAutoConfigurationImportSelector</code>会去扫描classpath下的所有<code>spring.factories</code>文件，然后进行bean的自动化配置。</p>
<p>所以，如果我们想要自定义一个starter的话，可以通过以上方式将自定义的starter中的bean自动化配置到Spring的上下文中，从而避免大量的配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/SpringBoot%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/SpringBoot%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">SpringBoot核心概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 22:12:39" itemprop="dateCreated datePublished" datetime="2021-01-08T22:12:39+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:06:55" itemprop="dateModified" datetime="2021-03-28T09:06:55+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>纵然Spring已经能够为我们提供种种我们所需要的功能了，但是它依然还是不完美的。<strong>基于Spring的程序需要进行很多的配置</strong>。比如我们要开发web应用程序，我们需要考虑使用哪些Spring模块以及其他的框架，并且还需要考虑框架之间的版本是否兼容。除此之外，我们还要进行大量的基础配置，配置来配置去，这种重复操作总会让人闻到一股怀味道。</p>
<p>Spring的开发者们注意到了这些问题，于是Spring Boot诞生了。</p>
<p>Spring Boot通过两个方式使得我们从上述的重复操作中得以解脱：</p>
<ul>
<li>Spring Boot Auto Configuration</li>
<li>Spring Boot Starter Project</li>
</ul>
<h3 id="一、Spring-Boot-Starter-Project"><a href="#一、Spring-Boot-Starter-Project" class="headerlink" title="一、Spring Boot Starter Project"></a>一、Spring Boot Starter Project</h3><p>Spring Boot像是一个大管家，我们只需要告诉他，我们要做什么类型的程序，由他来负责帮助我们去做具体的事情。还是以web开发为例，我们只需要告诉Spring Boot我要干一个web项目，去给我准备相关的东西，Spring Boot就会去干事了。具体到操作上就是，我们提供给Spring Boot一个<strong>spring-boot-starter-web</strong>的选项，Spring Boot就会知道我们的意思，然后为我们生成出来一个工程，这个工程就已经具备了所有web应用程序开发所需要的所有依赖，完全没必要我们自己再去到pom中手动配置。Spring Boot的文档是这样解释的：</p>
<blockquote>
<p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xin.desertcamel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-starter-web</code> 一个起步依赖。通过Maven的依赖传递，可以得到一个web工程所需要的全部基础依赖。可以理解为，<code>Spring Boot为我们提供了一层高级抽象，屏蔽了底层细节，在这个实例代码中，开发者所应该关注的事情是我要做一个什么样的项目，要实现这个项目的功能需要依赖哪些功能，而不用再去关心我要具体依赖哪些库，起步依赖同时也管理了所要依赖的库的版本，让开发者从繁琐的包管理中解脱出来，而更关注应用程序的业务实现。</code></p>
<p><parent>标签的意义是，我们可以继承spring boot的一些默认的选项:</parent></p>
<ul>
<li><p>默认编译级别为Java 1.6</p>
</li>
<li><p>源码编码为UTF-8</p>
</li>
<li><p>一个依赖管理节点，允许你省略普通依赖的<version>标签。</version></p>
</li>
</ul>
<p>如果不想从spring boot parent继承，可以这样做：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="二、Spring-Boot-Auto-Configuration"><a href="#二、Spring-Boot-Auto-Configuration" class="headerlink" title="二、Spring Boot Auto Configuration"></a>二、Spring Boot Auto Configuration</h3><p>除了自动管理项目依赖之外，Spring Boot也提供了自动配置的能力。</p>
<p>当我们开发web应用程序时，我们需要在xml中或java以代码的形式来配置基于Spring的开发环境。比如我们需要配置Dispatcher Servlet、DataSource、ViewResolver等等这些必须的bean，这些操作每次都是重复的，所以Spring Boot就把它们也自动化掉了。Spring Boot会检测ClassPath当中的jar包，如果包含了web开发所需要使用jar包（Spring MVC），Spring就会把上述所说的配置都配置好，不用我们再去配置。同样贴上官方的解释：</p>
<blockquote>
<p><em>Spring Boot looks at a) Frameworks available on the CLASSPATH b) Existing configuration for the application. Based on these, Spring Boot provides basic configuration needed to configure the application with these frameworks. This is called</em> <code>Auto Configuration</code>.</p>
</blockquote>
<p>Spring Boot会根据类路径中的jar包、类，为jar包里的类自动配置，这样可以极大的减少配置的数量。简单点说就是它会根据定义在classpath下的类，自动的给你生成一些Bean，并加载到Spring的Context中。自动配置充分的利用了spring 4.0的条件化配置特性，能够自动配置特定的Spring bean，用来启动某项特性。</p>
<h4 id="条件化配置"><a href="#条件化配置" class="headerlink" title="条件化配置"></a>条件化配置</h4><p>假设你希望一个或多个bean只有在某种特殊的情况下才需要被创建，比如，一个应用同时服务于中美用户，要在中美部署，有的服务在美国集群中需要提供，在中国集群中就不需要提供。在Spring 4之前，要实现这种级别的条件化配置是比较复杂的，但是，<strong>Spring 4</strong>引入了一个新的<code>@Conditional</code>注解可以有效的解决这类问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional(ChinaEnvironmentCondition.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceBean <span class="title">serviceBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>@Conditional(ChinaEnvironmentCondition.class)</code>条件的值为true的时候，该<code>ServiceBean</code>才会被创建，否则该bean就会被忽略。</p>
<p><code>@Conditional</code>指定了一个条件。他的条件的实现是一个Java类——<code>ChinaEnvironmentCondition</code>，要实现以上功能就要定义<code>ChinaEnvironmentCondition</code>类，并继承<code>Condition</code>接口并重写其中的<code>matches</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaEnvironmentCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Environment env = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containProperty(<span class="string">&quot;ENV_CN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，matches方法的内容比较简单，他通过给定的<code>ConditionContext</code>对象进而获取<code>Environment</code>对象，然后使用该对象检查环境中是否存在<code>ENV_CN</code>属性。如果存在该方法则直接返回true，反之返回false。当该方法返回true的时候，就符合了<code>@Conditional</code>指定的条件，那么<code>ServiceBean</code>就会被创建。反之，如果环境中没有这个属性，那么这个<code>ServiceBean</code>就不会被创建。</p>
<p>除了可以自定义一些条件之外，Spring 4本身提供了很多已有的条件供直接使用，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Servlet容器、Spring容器、SpringMVC容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 21:29:03" itemprop="dateCreated datePublished" datetime="2021-01-08T21:29:03+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 09:02:57" itemprop="dateModified" datetime="2021-03-28T09:02:57+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>本文基于一个问题：在使用 SpringMVC 时，Spring 容器是如何与 Servlet 容器进行交互的？</strong></p>
</blockquote>
<h2 id="Spring-容器的加载"><a href="#Spring-容器的加载" class="headerlink" title="Spring 容器的加载"></a>Spring 容器的加载</h2><p>可否还记得，当年还没有 Springboot 的时候，在 Tomcat 的 web.xml 中进行面向 xml 编程的青葱岁月？其中有那么几段配置总是令我记忆犹新：</p>
<p>首先是 Spring 容器配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">  &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<p>其次是 Servlet 容器监听器配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>在 Tomcat 启动时，根据这两段配置，究竟做了什么动作，使得 Tomcat 与 Spring 完美地结合在一起了呢？</p>
<p>首先我们来看下 ContextLoaderListener 监听器的源码：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320205328.png" alt="img"></p>
<p>我们发现它继承了 ContextLoader，并且实现了 ServletContextListener 接口，下面说下这两个东西的作用：</p>
<ol>
<li>ContextLoader：正如其名，ContextLoader 可以在启动时载入 IOC 容器；</li>
<li>ServletContextListener：ServletContextListener 接口有两个抽象方法，contextInitialized 和 contextDestroyed，该监听器会结合 Web 容器的生命周期被调，ContextLoaderListener 正是实现了该接口。</li>
</ol>
<p>因此，ContextLoaderListener 最主要的作用就是在 Tomcat 启动时，根据配置加载 Spring 容器。</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320205759.png" alt="img"></p>
<p>以上就是 ContextLoaderListener 实现 contextInitialized 方法的逻辑，也是加载并初始化 Spring 容器的开始。</p>
<p>org.springframework.web.context.ContextLoader#initWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320210832.png" alt="img"></p>
<p>以上代码逻辑主要做了以下几个操作：</p>
<ol>
<li>调用 createWebApplicationContext 方法创建一个容器，会创建一个 contextClass 类型的容器，如果没有配置，则默认创建 WebApplicationContext 类型的容器；</li>
<li>将容器强转为 ConfigurableWebApplicationContext 类型；</li>
<li>调用 configureAndRefreshWebApplicationContext 方法初始化 Spring 容器；</li>
<li>最后将 Spring 容器，以一个元素的形式保存到 Servlet 容器中，这也就意味着，得到 Servlet 容器，同时也可以得到 Spring 容器。</li>
</ol>
<p>还发现 Spring 容器保存到 Servlet 容器中的 key 为 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，我们顺藤摸瓜找到获取 Spring 容器的方法：</p>
<p>org.springframework.web.context.support.WebApplicationContextUtils#getWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320220655.png" alt="img"></p>
<p>关于这个方法在哪里调用后面有说到。</p>
<p>org.springframework.web.context.ContextLoader#configureAndRefreshWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320210900.png" alt="img"></p>
<p>以上是 Spring 容器初始化逻辑，其中，CONFIG_LOCATION_PARAM 即是我们在 xml 中配置的 contextConfigLocation 参数：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320212506.png" alt="img"></p>
<p>同时还会将 Servlet 容器保存到 Spring 容器中，最后调用 refresh 方法进行初始化。</p>
<p>在将 Spring 容器初始化最后以一个元素的形式保存到 Servlet 容器之后，那么 SpringMVC 在初始化时，是如何拿到 Spring 容器的呢？</p>
<p>我们继续看 SpringMVC 初始化是怎么操作的。</p>
<h2 id="SpringMVC-容器的加载"><a href="#SpringMVC-容器的加载" class="headerlink" title="SpringMVC 容器的加载"></a>SpringMVC 容器的加载</h2><p>SpringMVC 本质上来讲，就是一个大号的 Servlet，其各种机制都是围绕着一个名叫 DispatcherServlet 的 Servlet 展开的，因此它必然实现了 Servlet 接口，那么在 Tomcat 启动时，它必然会通过 Servlet#init 方法进行初始化动作，我在其调用链路上发现以下方法：</p>
<p>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320220032.png" alt="img"></p>
<p>DispatcherServlet 的父类同样有一个方法，该方法是加载 SpringMVC 容器，即源码中的 webApplicationContext：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320221939.png" alt="img"></p>
<p>我们发现，rootContext 就是 ContextLoaderListener 加载的 <strong>Spring 容器</strong>，在这里，它会以父容器的身份保存到 SpringMVC 容器中。</p>
<p>当然，如果是用 Springboot 环境，那么默认只会存在一个上下文环境，原因如下：</p>
<p>1、在 Springboot 应用程序启动时，在 SpringBootServletInitializer#onStartup 方法中，会创建一个 rootAppContext 容器，如下：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320235338.png" alt="img"></p>
<p><strong>同时将上文所说的 ContextLoaderListener 监听器添加到 Servlet 容器中，同样达到了 xml 配置的效果</strong>，而调用 createRootApplicationContext 方法创建 rootAppContext 容器时，会将 contextClass 设置为 AnnotationConfigServletWebServerApplicationContext.class。</p>
<p>2、DispatcherServlet 此时作为一个 Bean，实现了 ApplicationContextAware 接口，会自动将上下文环境保存到 webApplicationContext 字段中；</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320233807.png" alt="img"></p>
<p>DispatcherServlet 初始化时，经过 debug 可以看到，rootContext 和 webApplicationContext 是同一个实例对象：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320231335.png" alt="img"></p>
<p>原因是通过 ContextLoaderListener 加载的上下文环境，通过 ApplicationContextAware 接口自动 set 进来保存到 DispatcherServlet 的 webApplicationContext 变量中了。</p>
<p>在 FrameworkServlet#initWebApplicationContext 方法最后，最终会将 webApplicationContext 注入以一个元素的形式保存到 Servlet 容器中：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200320234137.png" alt="img"></p>
<h2 id="DispatcherServlet-初始化"><a href="#DispatcherServlet-初始化" class="headerlink" title="DispatcherServlet 初始化"></a>DispatcherServlet 初始化</h2><p>最终，SpringMVC 初始化会调用该方法：</p>
<p>org.springframework.web.servlet.DispatcherServlet#onRefresh</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200321000909.png" alt="img"></p>
<p>DispatcherServlet 初始化时，从 Spring 容器中获取相关 Bean，初始化各种不同的组件，比如初始化 HandlerMapping：</p>
<p><img src="/techSnapshot.github.io/2021/01/08/Servlet%E5%AE%B9%E5%99%A8%E3%80%81Spring%E5%AE%B9%E5%99%A8%E3%80%81SpringMVC%E5%AE%B9%E5%99%A8/20200321001725.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本质上来讲，Servlet 容器与 Spring 容器并不互通，但因为有 Servlet 容器的监听器 ServletContextListener，在它们之间构筑了桥梁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://programmerlz.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/techSnapshot.github.io/images/avatar.gif">
      <meta itemprop="name" content="liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小楼昨夜又东风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/techSnapshot.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-10 13:59:32" itemprop="dateCreated datePublished" datetime="2019-05-10T13:59:32+08:00">2019-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 07:21:49" itemprop="dateModified" datetime="2021-03-29T07:21:49+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/techSnapshot.github.io/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动态代理简介"><a href="#动态代理简介" class="headerlink" title="动态代理简介"></a>动态代理简介</h2><p><strong>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制</strong>。很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>代理模式以及装饰器模式的一种实现。能够实现<strong>调用者</strong>和<strong>实现者</strong>之间的<strong>解耦</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/techSnapshot.github.io/2019/05/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/techSnapshot.github.io/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/techSnapshot.github.io/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/techSnapshot.github.io/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/techSnapshot.github.io/lib/anime.min.js"></script>
  <script src="/techSnapshot.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/techSnapshot.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/techSnapshot.github.io/js/utils.js"></script>

<script src="/techSnapshot.github.io/js/motion.js"></script>


<script src="/techSnapshot.github.io/js/schemes/muse.js"></script>


<script src="/techSnapshot.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
